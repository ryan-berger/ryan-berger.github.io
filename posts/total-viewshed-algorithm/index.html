<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Finding The Longest Line of Sight With CacheTVS | Ryan Berger's Page</title><meta name=keywords content><meta name=description content="Welcome all readers from the finding the longest line of sight post
The past 6 months of my almost every moment of my free time has been spent developing an algorithm with my friend
Tom Buckley-Houston to exhaustively prove that we&rsquo;ve found the longest line of sight. We both felt it was very
doable algorithmically, but current options looked extremely computationally intensive.
Since the inception of the project, through hard work and collaboration we have been able to speed up the calculations
by hundreds of times, and make it entirely feasible on top-of-the-line CPUs such as the AMD Turin.
Please enjoy the deep dive, and make sure to check out https://alltheviews.world for the final product!"><meta name=author content="Ryan Berger"><link rel=canonical href=https://ryan.berge.rs/posts/total-viewshed-algorithm/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://ryan.berge.rs/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://ryan.berge.rs/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ryan.berge.rs/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://ryan.berge.rs/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://ryan.berge.rs/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ryan.berge.rs/posts/total-viewshed-algorithm/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:url" content="https://ryan.berge.rs/posts/total-viewshed-algorithm/"><meta property="og:site_name" content="Ryan Berger's Page"><meta property="og:title" content="Finding The Longest Line of Sight With CacheTVS"><meta property="og:description" content="Welcome all readers from the finding the longest line of sight post
The past 6 months of my almost every moment of my free time has been spent developing an algorithm with my friend Tom Buckley-Houston to exhaustively prove that we’ve found the longest line of sight. We both felt it was very doable algorithmically, but current options looked extremely computationally intensive.
Since the inception of the project, through hard work and collaboration we have been able to speed up the calculations by hundreds of times, and make it entirely feasible on top-of-the-line CPUs such as the AMD Turin. Please enjoy the deep dive, and make sure to check out https://alltheviews.world for the final product!"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-01T20:10:00-07:00"><meta property="article:modified_time" content="2026-02-01T20:10:00-07:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Finding The Longest Line of Sight With CacheTVS"><meta name=twitter:description content="Welcome all readers from the finding the longest line of sight post
The past 6 months of my almost every moment of my free time has been spent developing an algorithm with my friend
Tom Buckley-Houston to exhaustively prove that we&rsquo;ve found the longest line of sight. We both felt it was very
doable algorithmically, but current options looked extremely computationally intensive.
Since the inception of the project, through hard work and collaboration we have been able to speed up the calculations
by hundreds of times, and make it entirely feasible on top-of-the-line CPUs such as the AMD Turin.
Please enjoy the deep dive, and make sure to check out https://alltheviews.world for the final product!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ryan.berge.rs/posts/"},{"@type":"ListItem","position":2,"name":"Finding The Longest Line of Sight With CacheTVS","item":"https://ryan.berge.rs/posts/total-viewshed-algorithm/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Finding The Longest Line of Sight With CacheTVS","name":"Finding The Longest Line of Sight With CacheTVS","description":"Welcome all readers from the finding the longest line of sight post\nThe past 6 months of my almost every moment of my free time has been spent developing an algorithm with my friend Tom Buckley-Houston to exhaustively prove that we\u0026rsquo;ve found the longest line of sight. We both felt it was very doable algorithmically, but current options looked extremely computationally intensive.\nSince the inception of the project, through hard work and collaboration we have been able to speed up the calculations by hundreds of times, and make it entirely feasible on top-of-the-line CPUs such as the AMD Turin. Please enjoy the deep dive, and make sure to check out https://alltheviews.world for the final product!\n","keywords":[],"articleBody":"Welcome all readers from the finding the longest line of sight post\nThe past 6 months of my almost every moment of my free time has been spent developing an algorithm with my friend Tom Buckley-Houston to exhaustively prove that we’ve found the longest line of sight. We both felt it was very doable algorithmically, but current options looked extremely computationally intensive.\nSince the inception of the project, through hard work and collaboration we have been able to speed up the calculations by hundreds of times, and make it entirely feasible on top-of-the-line CPUs such as the AMD Turin. Please enjoy the deep dive, and make sure to check out https://alltheviews.world for the final product!\nViewshed Algorithms A viewshed is all the area visible from a particular location on the map:\nIt also happens to hold the longest line of sight, since it is the furthest visible point from the observer.\nTraditional viewshed algorithms take Digital Elevation Mappings (DEMs) and calculate the angles pair-wise for all points and then determine whether there are obstructions. This approach works well for a single viewshed, however, scaling to more than one runs head-first into cache issues.\nYou could imagine if you naively apply this pair-wise computation you end up re-fetching and re-calculating quite a lot. Tools like ArcGIS do single viewshed calculations on the order of minutes, which works just fine for a single viewshed but makes every point on the planet algorithmically infeasible, so a new solution was needed. We needed a “total viewshed”, not just a single viewshed.\nEnter, the total viewshed algorithm.\nTotal Viewsheds Some literature exists for calculating total viewsheds for larger maps, notably, there are some prolific authors who have published many papers INSERT SPANISH RESEARCHERS. My friend Tom read (INSERT 2018 PAPER) back in 2020 while researching how to find the longest line of sight, which had been a dream of his.\nIn the paper, they lay out a solution that attempts to share a lot of the work that is done during a single viewshed calculation. This approach made use of Linear Algebra to find the closest points to a normal vector (that they call the sector) so they can sort them and process each line of sight in order by distance.\n(INSERT GRAPHIC ABOUT SECTOR DISTANCES)\nThey stuff the offsets into a linked list which they ship off to a GPU where they walk it in parallel calculating lines of sight.\nVery quickly, Tom noticed that the linked list is not a good idea. In fact, these distances from a sector are always going to have some upper bound, so we can at least pre-allocate a vector of that size. Tom called these “deltas”. Each angle had its own deltas (since the normal vector changes as you rotate the unit vector in space) so that each point inside the DEM could then run the usual viewshed algorithm on it. This is where it was left off until last year when Tom ported it to Rust.\nEnter The Rabbithole After rubbing some braincells together on the problem and re-implementing the algorithm myself, I noticed a complete lack of cache locality. The total viewshed algorithms may not have to recompute the offsets for each point, but it is effectively a single viewshed algorithm applied for every point, not exactly good for having to compute every viewshed.\nEach of the offsets or “deltas” used are not processed in any particular order, meaning going from (0, 0) to (0, 1) on the coordinate plane could mean that you are accessing completely different elevations when walking at a diagonal. Effectively benchmarking your processors prefetcher with the number of cache misses you’ll incur.\nHow bad are these cache misses? Well, the elevation data we have is at a resolution of 100m so for Mount Everest’s 600km x 600km worst case line of sight we are talking 36 million elevations. Those elevations are stored as i16s totaling 72MBs. Much bigger than what L3 can fit.\nTo solve this you could order access along the line of sight so that the next line of sight calculation starts at the result of adding the “delta” to where you are currently processing. This would definitely solve some of your cache issues, however, some astute readers may realize that a cache line is 64 bytes, meaning accessing at random offsets means you over-fetch by a factor of 4. 75% of your cache hits are completely wasted, unless you can hit 4 times your line of sight in a single cache line, a tall order.\nSo, how do we solve both processing the line of sight in an orderly and cache efficient manner? Well, what if I told you that we could take all of those cache misses up front\nEnter, CacheTVS, a total viewshed algorithm that trades a very small amount of accuracy for a huge amount of cache locality.\nMath Nerd (Arc)tangent: We don’t actually need to carry out \\(tan^{-1}\\) because it is continuous and monotonically increasing on \\((-\\infty, \\infty)\\). i.e. \\( tan^{-1}(x_1) \u003e tan^{-1}(x_2) \\implies x_1 \u003e x_2 \\).\n","wordCount":"845","inLanguage":"en","datePublished":"2026-02-01T20:10:00-07:00","dateModified":"2026-02-01T20:10:00-07:00","author":[{"@type":"Person","name":"Ryan Berger"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://ryan.berge.rs/posts/total-viewshed-algorithm/"},"publisher":{"@type":"Organization","name":"Ryan Berger's Page","logo":{"@type":"ImageObject","url":"https://ryan.berge.rs/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://ryan.berge.rs/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://ryan.berge.rs/blog/ title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ryan.berge.rs/>Home</a>&nbsp;»&nbsp;<a href=https://ryan.berge.rs/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Finding The Longest Line of Sight With CacheTVS
<span class=entry-hint title=Draft><svg height="35" viewBox="0 -960 960 960" fill="currentColor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h1><div class=post-meta><span title='2026-02-01 20:10:00 -0700 -0700'>February 1, 2026</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Ryan Berger</div></header><div class=post-content><p><em>Welcome all readers from the finding the longest line of sight post</em></p><p>The past 6 months of my almost every moment of my free time has been spent developing an algorithm with my friend
Tom Buckley-Houston to exhaustively prove that we&rsquo;ve found the longest line of sight. We both felt it was very
doable algorithmically, but current options looked extremely computationally intensive.</p><p>Since the inception of the project, through hard work and collaboration we have been able to speed up the calculations
by hundreds of times, and make it entirely feasible on top-of-the-line CPUs such as the AMD Turin.
Please enjoy the deep dive, and make sure to check out <a href=https://alltheviews.world>https://alltheviews.world</a> for the final product!</p><h2 id=viewshed-algorithms>Viewshed Algorithms<a hidden class=anchor aria-hidden=true href=#viewshed-algorithms>#</a></h2><p>A <a href=https://en.wikipedia.org/wiki/Viewshed>viewshed</a> is all the area visible from a particular location on the map:</p><figure class=align-center><img loading=lazy src=/lines/cardiff_viewshed.webp#center></figure><p>It also happens to hold the longest line of sight, since it is the furthest
visible point from the observer.</p><p>Traditional viewshed algorithms take Digital Elevation Mappings (DEMs) and calculate the angles pair-wise for all points
and then determine whether there are obstructions. This approach works well for a single viewshed, however, scaling to
more than one runs head-first into cache issues.</p><p>You could imagine if you naively apply this pair-wise computation you end up re-fetching and re-calculating quite a lot.
Tools like ArcGIS do single viewshed calculations on the order of minutes, which works just fine for a single viewshed
but makes every point on the planet algorithmically infeasible, so a new solution was needed. We needed a &ldquo;total viewshed&rdquo;,
not just a single viewshed.</p><p>Enter, the total viewshed algorithm.</p><h3 id=total-viewsheds>Total Viewsheds<a hidden class=anchor aria-hidden=true href=#total-viewsheds>#</a></h3><p>Some literature exists for calculating total viewsheds for larger maps, notably, there are some prolific
authors who have published many papers INSERT SPANISH RESEARCHERS. My friend Tom read (INSERT 2018 PAPER) back in
2020 while researching how to find the longest line of sight, which had been a dream of his.</p><p>In the paper, they lay out a solution that attempts to share a lot of the work that is done during a single viewshed calculation.
This approach made use of Linear Algebra to find the closest points to a normal vector (that they call the sector)
so they can sort them and process each line of sight in order by distance.</p><p>(INSERT GRAPHIC ABOUT SECTOR DISTANCES)</p><p>They stuff the offsets into a linked list which they ship off to a GPU where they walk it in parallel
calculating lines of sight.</p><p>Very quickly, Tom noticed that the linked list is not a good idea. In fact, these distances from a sector are always
going to have some upper bound, so we can at least pre-allocate a vector of that size. Tom called these &ldquo;deltas&rdquo;.
Each angle had its own deltas (since the normal vector changes as you rotate the unit vector in space) so that
each point inside the DEM could then run the usual viewshed algorithm on it. This is where it was left off
until last year when Tom ported it to Rust.</p><h2 id=enter-the-rabbithole>Enter The Rabbithole<a hidden class=anchor aria-hidden=true href=#enter-the-rabbithole>#</a></h2><p>After rubbing some braincells together on the problem and re-implementing the algorithm myself, I noticed a complete lack
of cache locality. The total viewshed algorithms may not have to recompute the offsets for each point, but it
is effectively a single viewshed algorithm applied for every point, not exactly good for having to compute every viewshed.</p><p>Each of the offsets or &ldquo;deltas&rdquo; used are not processed in any particular order, meaning going from (0, 0) to (0, 1)
on the coordinate plane could mean that you are accessing completely different elevations when walking at a diagonal.
Effectively benchmarking your processors prefetcher with the number of cache misses you&rsquo;ll incur.</p><p>How bad are these cache misses? Well, the elevation data we have is at a resolution of 100m so for
Mount Everest&rsquo;s <a href=TOMLINK>600km x 600km worst case line of sight</a> we are talking 36 million elevations.
Those elevations are stored as i16s totaling 72MBs. Much bigger than what L3 can fit.</p><p>To solve this you could order access along the line of sight so that the next line of sight calculation starts
at the result of adding the &ldquo;delta&rdquo; to where you are currently processing. This would definitely solve
some of your cache issues, however, some astute readers may realize that a cache line is 64 bytes, meaning
accessing at random offsets means you over-fetch by a factor of 4. 75% of your cache hits are completely wasted, unless
you can hit 4 times your line of sight in a single cache line, a tall order.</p><p>So, how do we solve both processing the line of sight in an orderly and cache efficient manner? Well, what if I told
you that we could take all of those cache misses up front</p><p>Enter, CacheTVS, a total viewshed algorithm that trades a very small amount of accuracy for a huge amount
of cache locality.</p><h4 id=math-nerd-arctangent>Math Nerd (Arc)tangent:<a hidden class=anchor aria-hidden=true href=#math-nerd-arctangent>#</a></h4><p>We don&rsquo;t actually need to carry out \(tan^{-1}\) because it is continuous and monotonically
increasing on \((-\infty, \infty)\). i.e. \( tan^{-1}(x_1) > tan^{-1}(x_2) \implies x_1 > x_2 \).</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ryan.berge.rs/>Ryan Berger's Page</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>