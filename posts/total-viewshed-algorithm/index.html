<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>A Total Viewshed Algorithm to Find the Longest Line of Sight | Ryan Berger's Page</title><meta name=keywords content><meta name=description content="
Welcome all readers from the non-technical lines of sight post

The past 6 months of almost every moment of my free time has been spent developing an algorithm with my friend
Tom Buckley-Houston to exhaustively prove that we&rsquo;ve found the longest line of sight in the world.
We both felt it was very doable algorithmically, but current options looked extremely computationally intensive.
Since the inception of the project, through hard work and collaboration, we have been able to speed up the calculations
by hundreds of times, and make it entirely feasible on top-of-the-line CPUs such as the AMD Turin.
Please enjoy the deep dive, and make sure to check out Tom&rsquo;s sister-blogpost
and https://alltheviews.world for the final product!"><meta name=author content="Ryan Berger"><link rel=canonical href=https://ryan.berge.rs/posts/total-viewshed-algorithm/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://ryan.berge.rs/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://ryan.berge.rs/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ryan.berge.rs/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://ryan.berge.rs/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://ryan.berge.rs/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ryan.berge.rs/posts/total-viewshed-algorithm/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:url" content="https://ryan.berge.rs/posts/total-viewshed-algorithm/"><meta property="og:site_name" content="Ryan Berger's Page"><meta property="og:title" content="A Total Viewshed Algorithm to Find the Longest Line of Sight"><meta property="og:description" content=" Welcome all readers from the non-technical lines of sight post
The past 6 months of almost every moment of my free time has been spent developing an algorithm with my friend Tom Buckley-Houston to exhaustively prove that we’ve found the longest line of sight in the world. We both felt it was very doable algorithmically, but current options looked extremely computationally intensive.
Since the inception of the project, through hard work and collaboration, we have been able to speed up the calculations by hundreds of times, and make it entirely feasible on top-of-the-line CPUs such as the AMD Turin. Please enjoy the deep dive, and make sure to check out Tom’s sister-blogpost and https://alltheviews.world for the final product!"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-01T20:10:00-07:00"><meta property="article:modified_time" content="2026-02-01T20:10:00-07:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="A Total Viewshed Algorithm to Find the Longest Line of Sight"><meta name=twitter:description content="
Welcome all readers from the non-technical lines of sight post

The past 6 months of almost every moment of my free time has been spent developing an algorithm with my friend
Tom Buckley-Houston to exhaustively prove that we&rsquo;ve found the longest line of sight in the world.
We both felt it was very doable algorithmically, but current options looked extremely computationally intensive.
Since the inception of the project, through hard work and collaboration, we have been able to speed up the calculations
by hundreds of times, and make it entirely feasible on top-of-the-line CPUs such as the AMD Turin.
Please enjoy the deep dive, and make sure to check out Tom&rsquo;s sister-blogpost
and https://alltheviews.world for the final product!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ryan.berge.rs/posts/"},{"@type":"ListItem","position":2,"name":"A Total Viewshed Algorithm to Find the Longest Line of Sight","item":"https://ryan.berge.rs/posts/total-viewshed-algorithm/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A Total Viewshed Algorithm to Find the Longest Line of Sight","name":"A Total Viewshed Algorithm to Find the Longest Line of Sight","description":" Welcome all readers from the non-technical lines of sight post\nThe past 6 months of almost every moment of my free time has been spent developing an algorithm with my friend Tom Buckley-Houston to exhaustively prove that we\u0026rsquo;ve found the longest line of sight in the world. We both felt it was very doable algorithmically, but current options looked extremely computationally intensive.\nSince the inception of the project, through hard work and collaboration, we have been able to speed up the calculations by hundreds of times, and make it entirely feasible on top-of-the-line CPUs such as the AMD Turin. Please enjoy the deep dive, and make sure to check out Tom\u0026rsquo;s sister-blogpost and https://alltheviews.world for the final product!\n","keywords":[],"articleBody":" Welcome all readers from the non-technical lines of sight post\nThe past 6 months of almost every moment of my free time has been spent developing an algorithm with my friend Tom Buckley-Houston to exhaustively prove that we’ve found the longest line of sight in the world. We both felt it was very doable algorithmically, but current options looked extremely computationally intensive.\nSince the inception of the project, through hard work and collaboration, we have been able to speed up the calculations by hundreds of times, and make it entirely feasible on top-of-the-line CPUs such as the AMD Turin. Please enjoy the deep dive, and make sure to check out Tom’s sister-blogpost and https://alltheviews.world for the final product!\nAs it is truly 6 months worth of information, I’ve broken it up into 3 main chunks, with an intermission:\nAn introduction to the total viewshed and lines of sight algorithm, which is required reading for the other two. Data layout and how that affects performance, and the optimizations we found to make the most of the CPU cache. An intermission.\nFinding the longest line of sight, via multithreading, SIMD, and instruction level parallelism all with the safety of Rust! Use these links along with the Table of Contents drop-down above to digest at your leisure!\nThe Total Viewshed Algorithm A viewshed is all the area visible from a particular location on the map:\nIt also happens to hold the longest line of sight, since it is the furthest visible point from the observer.\nTraditional viewshed algorithms take Digital Elevation Mappings (DEMs) and calculate the angles pair-wise for all points and then determine whether there are obstructions. This approach works well for a single viewshed, however, scaling to more than one runs head-first into cache issues.\nYou could imagine if you naively apply this pair-wise computation you end up re-fetching and re-calculating quite a lot. Tools like ArcGIS do single viewshed calculations on the order of minutes, which works just fine for a single viewshed but makes every point on the planet algorithmically infeasible, so a new solution was needed. We needed a “total viewshed” algorithm, not just a single viewshed.\nEnter, the total viewshed algorithm.\nLine of Sight Visibility At the foundation of the total (or single) viewshed algorithm lies the humble line of sight visibility calculation. The line of sight visibility is the measure of visibility for some slice of the viewshed, say one degree, which accumulated makes up a full viewshed.\nLine of sight visibility calculations are entirely boolean (is the point visible to the observer or not) and are entirely two-dimensional. To make this three-dimensional slice of space two-dimensional, we use an azimuthal projection to project our observer into a two-dimensional space.\nYes, ‘azimuthal projection’ is just a fancy way of describing the Google Map Guy™’s POV\nThe elevations “in front of” the observer on the y-axis, distance on the x. The line of sight may lie between two elevations so an interpolated value is chosen and a “band” of sight is also chosen, meaning the observer sees exactly one point at a time.\nThe angle of elevation between two points must also take into account the curvature of the earth, along with the refraction of light. The equation for adjusting the elevation for both is given by the following equation:\n$$ E^\\prime = E + (D^2(R - 1) / d_{earth}); \\newline $$\nWhere \\(E^\\prime\\) is the adjusted elevation, \\(D\\) is the distance to the point, \\(R\\) is a refraction coefficient which has been calculated to be \\(\\approx.13\\), and \\(d_{earth}\\) is the diameter of the earth in kilometers.\nThe angle of elevation, \\(\\theta\\), between a point along the line of sight forms a right triangle. Since adjusted elevation is on the opposite side of the triangle, while the distance to the point is the adjacent side, \\(tan\\) will be our friend: $$ tan(\\theta) = (E^\\prime - h_{pov}) / D \\newline \\theta = tan^{-1}((E^\\prime - h_{pov}) / D) $$\nWhere \\(h_{pov}\\) is the height of the observer.\nMath Nerd (arc)Tangent:\nFor computational purposes we won’t actually carry out \\(tan^{-1}\\). We can get away with this because it is continuous and monotonically increasing on \\((-\\infty, \\infty)\\). This means \\( tan^{-1}(x_1) \u003e tan^{-1}(x_2) \\iff x_1 \u003e x_2 \\) so the extra computation doesn’t give us anything extra.\nOnce the angles of elevation are laid out, we can determine visibility for each point along the line of sight. A point is visible to the observer if the angle of elevation between the observer and the point is greater than all the angles of previous points. The angle between the point of view and itself \\(-\\infty\\) since there is “no angle” and we want all angles to be greater than it.\nCalculated angles of elevation, along with their respective ‘highest previously seen angle’\nHere our observer determines visibility at each point by checking to see if the current angle is greater than the maximum of all previous angles, which is pictured below the previous graphic’s angle calculation.\nRotating this line of sight calculation around for all the terrain within the worst case line of sight for a given point will give you 360 different bitmaps of which points are visible. You can use those to construct a viewshed.\nTada!\nThe State-of-the-Art Total Viewshed Algorithm Now that we have line of sight visibility down, we can move on to the meat and potatoes, the total viewshed.\nThere isn’t a ton of literature existing for calculating total viewsheds for large maps. However, there are a few prolific authors in the total viewshed space who have published many papers. Namely, Tabik et al. My friend Tom read their initial total viewshed paper back in 2017 while researching how to find the longest line of sight, which had been a dream of his.\nIn the paper, they lay out a solution that attempts to parallelize a single viewshed calculation to calculate a total viewshed. Their approach makes use of Linear Algebra to find the closest points to a normal vector (that they call the sector) so they can determine which points to sample along the line of sight visibility calculation. In the paper they call this “sector ordering”.\nSector distances are not necessarily uniform from point to point (even potentially zig-zagging) along the line of sight so they must also be kept track of.\nThis line of sight zigzags\nThey construct the line of sight projection using a linked list container like so:\nstruct node { node* prev; // previous elevation in line of sight node* next; // next elevation in line of sight int16* data; // elevation data float distance; // distance from pov } The linked list elevation data isn’t a copy of the elevation data, it is a pointer to it. This then gets shipped off to a GPU for visibility calculation. The linked list and sector distances get reconstructed for every line of sight for every point and angle duplicating a ton of work.\nVery quickly Tom found that the linked list is Not A Good Idea™. In fact, the maximum line of sight is always going to have some upper bound, so we can pre-allocate an array of that size. Rather than pointers, Tom calculated position-independent offsets into the DEM, which he called “deltas”.\nTom also was able to make a parallel array for the sector distance. This way you add your delta to get the elevation, you use the distance from the sector distance array, and then you are able to calculate the angle to the point along the line of sight.\nThose offsets stay the same for every angle, so Tom only ever had to calculate them once rather for each point like the other paper.\nDeltas are really just vectors you can add to get where you’re going\nWith deltas, you take your point of view’s index, add the delta, and it gives you the index into the DEM of your next point along your line of sight. Do this for every point for every angle and you have a total viewshed. No linked list or pointer indirection involved.\nTom left his improvements on the back burner for 8 years until July 2025 when he started porting it to Rust.\nOur Benchmark Viewshed Since Mount Everest is the tallest point in the world, the viewshed with its peak was a very attracting benchmark for us. We immediately made it our “north star”. You’ll notice that I through timings of per-angle benchmarks, all of them refer to Everest.\nThe worst case line of site was estimated to be 670km by Tom, but we wanted it just a tad smaller so we could run faster. So, we stuck with a nice round 600km. This also happens to be one of the biggest worst case lines of sight in the world, so if we could get it running fast on Everest, then surely the world would be right around the corner.\nTom’s initial runs showed that running all of Everest took about 12 hours. Our first test runs didn’t show any lines of sight over 400km, confirming 600km was a safe estimate. Once it came time to do the whole world though, this wouldn’t do.\nFor more on why there’s such a gap between the worst case line of sight and the actual longest line of sight check out this section in Tom’s blogpost.\nTom worried there may be even longer worst case lines of sight, such as 800km. An algorithm that has to check a DEM which has \\(n \\times n\\) elevations, and checking a total of \\(n\\) elevations along your line of sight for 360 angles, you are looking at potentially taking almost 2.4x longer with a 1.3x longer worst case line of sight.\nTom’s initial estimates were that this would cost us potentially hundreds of thousands of dollars and many months of spot instance compute (meaning it could be shut down at any time). This was not feasible for either of our time or money budgets, and I was certain that we could do better and calculate the whole world.\nEnter, me.\nBuilding A Cache Efficient Algorithm A Cache Nightmare After rubbing some braincells together on the problem and re-implementing the algorithm myself, I noticed a complete lack of cache locality. Tom’s total viewshed algorithms may not have to recompute the “deltas” for each point, but it is effectively a single viewshed algorithm applied for every point. Not exactly good for having to compute every viewshed.\nThe points are not processed in any particular order, meaning that while you are working from left to right within the DEM, you are likely accessing completely different elevations.\nThis effectively benchmarks your processor’s prefetcher with the number of cache misses you’ll incur, not the FLOPs.\nHow bad are these cache misses? Well, the elevation data we have is at a resolution of 100m. For our lower-than-needed upper bound of 600km for Mount Everest’s we are talking 36 million elevations. Those elevations are stored as i16s totaling ~72MBs. Much bigger than what L3 can fit.\nMy mind first went to “sorting by lines of sight”. Deltas take a single point and get us to the next point, but don’t care about what order you process points in. Since the next point is now in cache, it would be nice to reuse the data for the next line of sight calculation.\nHowever, this falls flat on its face very quickly for a very simple reason: a line of sight is not contiguous in terms of memory. By accessing non-contiguous memory you may be loading some of the data into cache, but most of it is not being used in the line of sight calculation.\nAll the red bars are the full cache line of points your CPU fetches when asked to load the green points\nIn fact, in the worst case, since elevation data is stored as an i16 you are wasting 96% of a 64 byte cache line. OUCH.\nWith that much data being wasted, I set out to try to guarantee all data accesses for all lines of sight were contiguous, and wouldn’t you have it, all the squinting and rotating my head paid off.\nSpinning In Circles After staring at deltas and their corresponding distances for much too long, the deltas for 45 degrees popped out to me as particularly interesting. Not only were lines of sight much faster to calculate for 45 degrees, but visualizing the deltas showed that they create perfectly diagonal lines from the point of view and going across the DEM. The distances were also entirely uniform between points.\nSince these lines are perfectly straight, why couldn’t I make them entirely contiguous in memory and process the lines of sight from left to right instead of corner to corner?\nThis looked absolutely too good to be true! Surely rotating the map only works for some points but not all. And maybe it gets strange at angles that aren’t divisible by 45 and the whole idea is dead in the water? Would the distances be able to stay continuous? After wondering if this was doable or missing points, Tom and I sat down, convinced ourselves that this was possible and generated this image:\nA circle seen forming in the center of the DEM from all the rotations\nTom had already noticed that the original authors were only calculating lines of sight internally to the DEM. When it came to calculating the full line of sight for every point they stopped short, mentioning it as a limitation of the algorithm. This results in very few full viewsheds actually being valid.\nHowever, if you have 3x the data padding the tile, all lines of sight will be able to be calculated for lines of sight for all angles. While messing with rotations, we realized that only 2 times the data is required for computing the line of sight per angle. Instead of rotating the entire DEM, we only need to rotate a rectangular portion, which we nick-named the “chocolate bar”\nA chocolate bar in all its glory\nThe square tiles were now outliving their usefulness. When rotating the rectangle, it sometimes “juts” outside the DEM, meaning we don’t have the data for it. We nick-named these “dolphins” because they create little triangles when overlaid with the DEM that look like a dolphin’s top fin.\nA dolphin fin\nDolphins occur because squares don’t have infinite rotational symmetry so stuffing a rotated tile back into a square causes it to be cut off. To fix this, we can just use circular tiles. The total viewshed is still padded with 3x the data, except it is now 3 times the diameter of the worst-case longest line of sight.\nThe deltas and sector distances are dead! Viva la Rotación!\nThe Stars (Mostly) Align Now that we rotate the map, we completely front-load all our cache misses and perfectly align our data for our line of sight calculations. Of course, this is all unidirectional as we are only calculating the line of sight for all points at a single angle. This rotation itself incurs roughly a one-second penalty for even the biggest DEMs. A huge win.\nCutting down the amount of data ends up meaning we can fit multiple widths worth of the DEM into L1 for calculation. Another HUGE win.\nThere is one downside that bears mentioning: when calculating the rotated coordinates for an elevation it may not fall between a single elevation evenly. You have to interpolate some elevation there so that a line of sight calculation can be performed and not just have missing data. This is called rasterization.\nA rasterized triangle, courtesy of scratchpixel\nWe chose the “nearest neighbor” interpolation algorithm because it is extremely easy to implement and is considered to be within the acceptable margins of error established in the academic viewshed literature (See Siham Tabik et al. in Efficient Data Structure and Highly Scalable Algorithm for Total-Viewshed Computation https://ieeexplore.ieee.org/document/6837455).\nAttempting to make rotation a function mapping coordinates from the unrotated image onto to the rotated one also runs into trouble. Streaks will be unfilled because it isn’t guaranteed there is a one to one mapping of coordinates when there is rounding involved. Mathematically, we can see this because rotated points aren’t guaranteed to be unique due to \\(\\lfloor(x, y)\\rceil\\) meaning this function isn’t one to one:\n$$ rotate(x, y, \\theta): \\begin{bmatrix} cos \\theta \u0026 -sin \\theta \\\\ sin \\theta \u0026 cos \\theta \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} $$\n$$ DEM = \\{ 0 \\le x \u003c DEM_{width}; 0 \\le y \u003c DEM_{width} \\mid (x, y) \\} $$\n$$ DEM_{rotated} = \\{(x, y) \\in DEM \\mid \\lfloor rotate(x, y, \\theta) \\rceil \\} $$\n$$ DEM \\cap DEM_{rotated} \\neq DEM $$\nThis is solved by doing an “anti rotation”. Looping over all the points of the output image, and choosing the closest coordinate in the input.\n$$ anti\\_rotate(x, y, \\theta): rotate(x, y, -\\theta) $$\n$$ DEM_{rotated} = [ 0 \\le x \u003c DEM_{width}; 0 \\le y \u003c DEM_{width} \\mid DEM[\\lfloor anti\\_rotate(x, y, \\theta) \\rceil] ] $$\nNow it is guaranteed there’s a point in \\(DEM_{rotated}\\) for every \\((x, y)\\) but it isn’t guaranteed to be unique. This is fine for our purposes.\nA Brief Intermission Get up, go get a drink of water or coffee, breathe a little. We’re through the hardest part!\nPlease enjoy this Shiba who is a shop-keeper. Finding The Longest Line of Sight With CacheTVS Once we developed the optimal cache setup to guarantee that our calculations are no longer memory bound, the world became our oyster. A global total viewshed calculation seemed right on our doorstep.\nInitial runs showed that our algorithm ran at about ~120 seconds per angle for Everest with very little optimization, just straight-line Rust code. This timing means Everest takes 12 hours, but good news, it is single threaded so there’s plenty more to go.\nWith the high-level architecture complete we decided to name our algorithm, CacheTVS.\nCacheTVS has three different types of outputs:\nthe surface area heatmap, the point-by-point longest line of sight, the viewshed bitmaps The surface area heatmap is an estimate of the visible area from a point of view.\nThe point-by-point computation for the line of sight holds the angle and distance of the longest line of sight found.\nThe viewshed bitmaps are the boolean visibility computations out to the worst case line of sight for all 360 degrees.\nWe mainly only use the first two, as we calculated that storing the viewshed bitmap for Everest would be a few Terabytes worth of information, and it doesn’t actually give us anything extra. The world would be many Petabytes. We really only need a visualization of how much area each point can see, and of course the longest line of sight.\nAlso, we personally don’t have hard drives big enough :(\nIn total, we use exactly 8 times the amount of data of a single DEM which is entirely feasible and only around 200GB for the entire world.\nMultithreading As mentioned previously, all our initial tests were single threaded. Since the total viewshed calculation works on an angle by angle snapshot of the data, we can already parallelize this by the number of cores what we have, which for my machine is 8 cores. Because this workload is compute heavy, it doesn’t make sense to make use of SMT since threads will be fighting heavily for compute units.\nTo get the new time with 8-way parallelism, we just divide the amount of work, 360 angles, by the amount of cores and multiply by the number of seconds.\n$$ ((360 / 8) * 120\\space secs) / 60 \\space secs \\newline = ~1.5 \\space hrs $$\nWe’re under two hours for all of everest!\nInstruction Level Parallelism With the easy parallelization out of the way, it is time to see if we can squeeze extra parallelism out of our processor. There are many ways in which a CPU is parallel, not just multi-threading. You also have instruction-level parallelism along with SIMD. Initially, lets focus on the first. Speaking of, what does our line of sight calculation currently look like?\nfn line_of_sight(pov_height: i16, refraction: f32, elevations: \u0026[i16]) -\u003e (f32, f32) { // (surface area, distance) let mut highest_angle = -f32::INF; let mut longest_distance = 0.0f32; let mut surface_area = 0.0f32; for (distance, elevation) in elevations.enumerate() { // calculate the curve and refraction adjustment let curve_and_refraction = ((distance.ipow(2) as f32) * (1 - refraction)) / EARTH_DIAMETER; let elevation_prime = (elevation as f32) + curve_and_refraction // calculate the \"angle\" (really a ratio, not arctan) let angle = (elevation_prime - (pov_height as f32)) / distance // as we determined in the beginning, if the angle is higher, // then the point along our elevation map is visible. // // Add its area to the surface area, and update the longest // distance we've seen, and set it as the new highest angle if angle \u003e highest_angle { longest_distance = distance as f32 highest_angle = angle // TAN_ONE_RADIAN comes from the original paper. I'm not // sure that it is correct, but it makes for a decent estimate surface_area += distance * TAN_ONE_RADIAN } } (surface_area, longest_distance) } The main performance issues of this loop arise because each iteration depends on the last.\nCPUs work best when the next instruction doesn’t depend on the result of any other instruction before it. It uses instruction pipelining to issue multiple instructions, allowing instructions to work in parallel so long as there are no inter-instruction dependencies. This is called Instruction Level Parallelism (ILP).\nA 5-stage CPU pipeline courtesy of GeekForGeeks\nIn the case of the line of sight, the computation that is truly independent of any iteration is the angle computation. It is only based on distance and elevation, not any angle before or after.\nTo be able to unshackle it from the loop-carry dependency, we will trade off storing and re-loading it from memory for extra ILP. Thankfully this all still fits in L1 so the ILP benefits far outweigh the memory cost.\nWe can rewrite the loop as follows:\nfn line_of_sight(pov_height: i16, refraction: f32, elevations: \u0026[i16], angle_buf: \u0026mut [f32]) -\u003e (f32, f32) { // (surface area, distance) assert_eq(elevations.len(), angle_buf.len()) for (angle, (distance, elevation)) in zip(angle_buf.iter_mut(), elevations.enumerate()) { // calculate the curve and refraction adjustment let curve_and_refraction = ((distance.ipow(2) as f32) * (1 - refraction)) / EARTH_DIAMETER; let elevation_prime = (elevation as f32) + curve_and_refraction *angle = (elevation_prime - (pov_height as f32)) / distance } let mut highest_angle = -f32::INF; let mut longest_distance = 0.0f32; let mut surface_area = 0.0f32; for angle in angles { // as we determined in the beginning, if the angle is higher, // then the point along our elevation map is visible. // // Add its area to the surface area, and update the longest // distance we've seen, and set it as the new highest angle if angle \u003e highest_angle { longest_distance = distance as f32 highest_angle = angle // TAN_ONE_RADIAN comes from the original paper. I'm not // sure that it is correct, but it makes for a decent estimate surface_area += distance * TAN_ONE_RADIAN } } (surface_area, longest_distance) } We’ve now maximized the ILP of the angle calculation, but the longest line of sight calculation and surface area calculation still aren’t particularly parallel. Let’s fix that!\nPrefix Sums and Scans A prefix sum is a computation that takes a list of numbers and maps it to another list where each element becomes the cumulative sum of all elements before it, hence its name. Here’s a sample implementation:\nlet nums = \u0026[1, 2, 3, 4, 5]; let mut prefix_sum = \u0026[0, 0, 0, 0, 0]; let mut prefix_acc = 0; for (prefix, num) in zip(prefix_sum.iter_mut(), nums) { prefix_acc += num; *prefix_sum = prefix_acc } Abstractly, a prefix sum is part of a general family of algorithms called an “inclusive scan”. A scan is an even more general algorithm that takes a sequence, an associative binary operator, and applies the binary operator to an accumulated value and yields the newly accumulated value. Rust has this in its standard library with .iter().scan()\nlet nums = \u0026[1, 2, 3, 4, 5]; // yields the same as above let prefix_sum = nums .iter() .scan(0, |acc, elem| { *acc += elem; Some(*acc) }) .collect() Why do we care about scans? Well, for the real numbers max also happens to be an associative binary operator.\nWhen we do our visibility calculations, we are comparing the current angle against the highest angle:\nif angle \u003e highest_angle { longest_distance = distance as f32 highest_angle = angle surface_area += distance * TAN_ONE_RADIAN } If we have a prefix maximum of all the previous angles, then we could independently calculate whether a particular point is visible by checking to see if angle \u003e prefix_max.\nFortunately for us, max also happens to be associative for the floating point values that we compute. Generally speaking, floating point values are not associative due to NaNs and signed zero. We never do any computation that could yield either result, meaning we are safe to use max associatively.\nInterestingly, I’m not the first person to think about the application of a prefix maximum for line of sight visibility calculations. While researching the parallel prefix max, I stumbled upon this interesting paper from all the way back in 1993. The author mentions line of sight visibility calculations as an off-hand example of a parallelizeable prefix scan: Great minds think alike, I guess\nScans have two variants, inclusive and exclusive. Careful readers may have realized we aren’t comparing the highest angle to the prefix maximum which includes itself (like the above prefix sum). Instead, we are comparing the angle to the maximum of all previous angles (exclusive of itself). For this reason, we use an exclusive prefix maximum.\nIf we allocate a second buffer and stuff the exclusive prefix maximum in there, our loop iterations calculating the total surface area become entirely independent of one another. Calculating the longest line of sight also falls out of our surface area calculation.\nHere’s the updated algorithm. I’ve broken it out into three separate functions as we now calculate the line of sight in three discrete steps:\nAngles Prefix maximum Visibility (surface area and longest line of sight) fn calculate_angles(pov_height: f32, refraction: f32, angle_buf: \u0026mut [f32], elevations: \u0026[i16]) { for (angle, (distance, elevation)) in zip(angle_buf.iter_mut(), elevations.enumerate()) { let curve_and_refraction = ((distance.ipow(2) as f32) * (1 - refraction)) / EARTH_DIAMETER; let elevation_prime = (elevation as f32) + curve_and_refraction *angle = (elevation_prime - (pov_height as f32)) / distance } } fn prefix_max(prefix_max_buf: \u0026mut [f32], angle_buf: \u0026[f32]) { let mut highest_seen = -f32::INF; for (prefix_max, (distance, angle)) in zip(prefix_max_buf.iter_mut(), angles.enumerate()) { *prefix_max = highest_seen; highest_seen = max(*prefix_max, highest_seen); } } fn visibility(angles: \u0026[f32], prefix_max: \u0026[f32]) -\u003e (f32, f32) { let longest_distance = 0.0f32; for ((distance, angle), prefix_max) in zip(angles.enumerate(), prefix_max) { if angle \u003e prefix_max { surface_area += distance * TAN_ONE_RADIAN longest_distance = distance } } (surface_area, longest_distance) } fn line_of_sight( pov_height: i16, refraction: f32, elevations: \u0026[i16], angle_buf: \u0026mut [f32], prefix_max_buf: \u0026mut [f32], ) -\u003e (f32, f32) { // (surface area, distance) assert_eq(elevations.len(), angle_buf.len()) calculate_angles(pov_height as f32, refraction, angle_buf, elevations); prefix_max(prefix_max_buf, angle_buf); visibility(angles, prefix_max) } Cache Pressure Ain’t Gonna Break My Stride Before parallelizing further, I noticed that our angle calculations redo the same curvature computation over and over. When you have potentially hundreds of millions of lines of sight to process, that’s quite a bit of extra computation. We haven’t hit an issue with cache pressure yet so let’s pre-compute the curve and refraction adjustment, and also pre-compute the distances between points. Tiles generally are all of the same scale, 100m, but we add it in for future use:\n// generate the curvature adjustments given the scale, refraction and worst case line of sight, `max_los`. fn generate_distances(max_los: usize, refraction: f32, scale: f32) -\u003e (Vec\u003cf32\u003e, Vec\u003cf32\u003e) { let adjusted_refraction = refraction - 1.0; (1..=max_los) .map(|step| { let distance = (step as f32) * scale; let adjustment = (distance * distance * adjusted_refraction) / EARTH_DIAMETER; (distance, adjustment) }) .unzip() } We now can run this once and keep it out of our angle calculation loop. Nice!\nClose enough, welcome back sector distances.\nSIMD We’ve almost squeezed every little bit of ILP out of our algorithm, so now is the time to talk about another type of parallelism. SIMD.\nSIMD stands for “Single Instruction Multiple Data”. SIMD widens registers by multiple times the width of data, say 8 f32s, and allows a single instruction to be issued to do computation on all elements at once.\nBecause of the parallel nature of our computation, we are a good fit for rewriting the algorithm in SIMD. Instead of calculating a single angle at a time, we can calculate 8 at a time on my x86 machine - which has AVX2 - and as we’ll see later, up to 16 at a time on AVX-512 machines.\nRust currently has an unstable nightly feature called “portable SIMD” which lets us abstract over the hardware architecture, which will work well for our most basic computations.\nTrivially, we can use portable SIMD to widen both our angle and longest line of sight computations. Check it out:\n// requires #![feature(portable_simd)] use std::simd::prelude::SimdFloat as _; use std::simd::{LaneCount, Simd, SupportedLaneCount}; // fancy itertools macro that lets us zip multiple iterators into one big unnested tuple use itertools::izip; fn calculate_angles\u003cconst VECTOR_WIDTH: usize\u003e( pov_height: f32, angles_out: \u0026mut [f32], elevations, distances, adjustments) where LaneCount\u003cVECTOR_WIDTH\u003e : SupportedLaneCount { assert(elevations.len().is_multiple_of(VECTOR_WIDTH)); // turn a \u0026[f32] into a \u0026[[f32; VECTOR_WIDTH]]. The r.h.s of the assignment // is the portion that doesn't fit into VECTOR_WIDTH, but we can ignore it since // the length of the slice is asserted to be a multiple of VECTOR_WIDTH let (vector_angles, _) = angles_out.as_chunks_mut::\u003c{ VECTOR_WIDTH }\u003e(); let (vector_elevations, _) = elevations.as_chunks::\u003c{ VECTOR_WIDTH }\u003e(); let (vector_adjustments, _) = adjustments.as_chunks::\u003c{ VECTOR_WIDTH }\u003e(); let (vector_distances, _) = distances.as_chunks::\u003c{ VECTOR_WIDTH }\u003e(); for (angle_out, \u0026elevation, \u0026distance, \u0026adjustment) in izip!( vector_angles.iter_mut(), vector_elevations.iter(), vector_distances.iter(), vector_adjustments.iter() ) { let elevation_f32: Simd\u003cf32, { VECTOR_WIDTH }\u003e = Simd::from(elevation).cast(); let elevation_prime = elevation_f32 + Simd::from_array(adjustment); let res = (elevation_prime - Simd::splat(pov_height)) / Simd::from_array(distance); res.copy_to_slice(angle_out); } } fn visibility\u003cconst VECTOR_WIDTH: usize\u003e(angles: \u0026[f32], prefix_max: \u0026[f32], distances: \u0026[f32]) -\u003e (f32, f32) where LaneCount\u003cVECTOR_WIDTH\u003e : SupportedLaneCount { assert(angles.len().is_multiple_of(VECTOR_WIDTH)); let (vector_angles, _) = angles.as_chunks::\u003c{ VECTOR_WIDTH }\u003e(); let (vector_prefix, _) = prefix_max.as_chunks::\u003c{ VECTOR_WIDTH }\u003e(); let (vector_distances, _) = distances.as_chunks::\u003c{ VECTOR_WIDTH }\u003e(); let (simd_area, simd_longest_distance) = izip(angles, distances, prefix_max) .fold((Simd::splat(0.0f32), Simd::splat(0.0f32)), |((acc_area, acc_distances), (angle, distance, prefix_max)) { let mask = angle.simd_gt(prefix_max); // if we don't have _any_ elements, then why carry out the rest of the computation? if !mask.any() { return (acc_area, acc_distances); } let selected_distances = mask.select(distance, Simd::splat(0.0f32)); let surface_area = selected_distances * Simd::splat(TAN_ONE_RADIAN); (acc_area + surface_area, acc_distances.simd_max(selected_distances)) }| } (simd_area.reduce_sum(), simd_longest_distance.reduce_max()) } Programming with SIMD is a very different way of thinking because as you may notice, there are no conditionals. Instead, each element is compared pairwise with each other to create a “mask”. Then, you use that mask to “select” which elements you want to use for true (the distances) and which to use for false (zero).\nRust has some interesting codegen for the !mask.any() that I haven’t fully grokked, so I’ll leave it for a second blog post. Suffice it to say that it still uses all vector instructions, and is able to shave 10% off of our time. If no points within the 8-wide vector are visible (which is very common), there’s no reason to do any other calculation, so there’s at least some intuition as to why it is faster.\nx86 and IEEE754 Rust strives to be a safe language, so all float computations are done without the fastmath flags. Enabling the fastmath flags in Rust is annoying, and also not recommended for various other reasons. One reason why you might want to turn on fastmath flags is that at least on x86, some instructions such as comparisons and floating point maximums end up generating a lot of extra instructions to comply with IEEE floating point standards because guess what: Intel’s instructions don’t.\nFor this project, we actually don’t care a ton about the IEEE standard for comparison or maximum as we aren’t generating any NaNs or signed zero. For x86 we implement max with the _mm_max_ps intrinsic and implement greater than with _mm_gt_ps. No extra instructions.\nThis gets more important in our next section because we are going to make use of the max instruction quite a bit, and we need to make sure the minimal number of instructions are generated. It’s all to help us stop avoiding the SIMD elephant in the room: the prefix maximum calculation.\nParallel Scans Calculating the prefix maximum with multiple threads would induce a huge amount of overhead for a small amount of work, so instead we want to parallelize our prefix maximum via SIMD. The level of parallelism we get out of the algorithm will be from clearing up the instruction pipeliner and keeping the carried dependencies minimal.\nBecause max is associative, we can calculate the prefix maximum for all the angles that fit within a single SIMD register, keeping all calculations independent of one another and make ILP go brrr. Then we loop back over the data to propagate the maximum of each through the data. A common pattern you may be picking up on.\nOnto an example.\nLet’s say we have the following angles in two 4-wide registers.\n[1, -1, 2, -2], [3, -3, 4, -4] We can calculate the prefix max of the first register by shifting in an identity element - in our case -f32::INF since max(x, -f32::INF) = x - and applying our binary operator max. Then we take the result of that and shift in two identity elements to finish calculating the prefix max in-place:\nmax([ 1, -1, 2, -2], [-INF, 1, -1, 2]) = [1, max(-1, 1), max(2, -1), max(-2, -1)] Then reuse that for the next in-place prefix max:\nmax([ 1, max(-1, 1), max(2, -1), max(-2, -1)], ; \u003c- First iteration [-INF, -INF, 1, max(1, -1)]) ; \u003c- First iteration, shifted twice = [1, max(-1, 1), max(max(2, -1), 1), max(max(-2, -1), max(1, -1))] = [1, 1, 2, 2] We do the same for the second register, independently:\nmax([ 3, -3, 4, -4], [-INF, 3, -3, 4]) = [3, max(-3, 3), max(4, -3), max(-4, 4)] Which needs to be reused for the next in-place prefix max:\nmax([ 3, max(-3, 3), max(4, -3), max(-4, 4)], [-INF, -INF, 3, max(1, -1)] = [3, 3, 4, 4] Now, we can take the maximum of the first register, which is always the last element, and splat it across a whole SIMD register, then call max with it and the second register to complete the process:\nmax([3, 3, 4, 4], [2, 2, 2, 2]) = [3, 3, 4, 4] No change here. But as you can see, associativity is what lets us do this prefix maximum calculation in-place and lets us only do \\(log_2(4) = 2\\) calls to max. When we use 8 or 16 wide registers it is still \\(log_2\\), so only a modest increase of one or two extra shifts. It also saves us from having to compute something like max(max(max(1, -1), 2), -2) which contains a computational dependency.\nWhen it comes to accumulating the max from previous vectors to the next ones, we just keep an accumulated maximum that we apply to each vector, completing the full scan and cementing our prefix maximum of all elements:\nlet mut local_acc = Simd::splat(highest); for prefix in vector_prefix { let cur_prefix: f32x4 = Simd::from(*prefix); // get the highest form the current vector let cur_max: f32x4 = Simd::splat(cur_prefix[3]); // apply the accumulator to the current vector and store it back _mm_maxps(local_acc, cur_prefix).copy_to_slice(prefix); // make sure the accumulator holds the result of max(cur_prefix[3], local_acc) local_acc = _mm_maxps(local_acc, cur_max); } There’s lots more details and not enough space, so if you are interested in the nitty-gritty, you can take a look at the implementation or take a look at this website or this paper which were great guides.\nAccumulating Now that we are able to calculate the longest line of sight for a given point, we need to do this for every point on the map. Since we also only go in a single direction, we need to run that for every angle.\nAs cores finish up doing their single angle heatmap and line of sight calculation, we simply accumulate their results into a single “final map”. At the end, the map accumulates data for all 360 degrees and we’re done! We have a total viewshed!\nIt should be noted that there are a good number of cores that get wasted when running with a core count that doesn’t evenly divide 360. Cores idling waiting for the next angle which doesn’t come. This matters for runs bigger than a single tile - but we leave this as future work.\nA Final Benchmark Viewshed Timing After implementing all of the above optimizations and absolutely squeezing the rock as hard as I could, water did in fact come out. We took Everest’s computation from 120 seconds an angle, down to:\nDRUM ROLL PLEASE\n75 seconds per angle.\nAstounding. This brought us down to 57 minutes for all of Everest on my 8 core machine. Every little bit of optimization and tuning brought us here, and it was because of the hard work we put in that we were getting very close to something usable for a world run. There was one last thing that was holding me back: AVX-512.\nVery, very recently, AMD released its Turin line of processor which has full AVX-512F support. Which means rather than having AVX-512 be two AVX2 calculations in a trench-coat, it is a first-class citizen. Renting a top of the line AMD Turin and our use of const generics and portable SIMD implementation let us seamlessly turn on support for a 16-wide angle calculation, prefix max, and longest line of sight calculation. Enabling it halved the time per angle, cutting down the calculation to an average of 35 seconds per angle.\nUsing the Turins also unlocked a huge number of extra cores. I found that 48 cores was the sweet spot for our algorithm. Now instead of taking an hour, with 48 cores and AVX512, we were taking 4 minutes for all of Everest. ALL OF EVEREST. This is a 160x speedup over the initial GPU algorithm.\nA Full World Run Now that we were confident that we had the quickest algorithm we could think up, it was time to run the longest line of sight algorithm for every tile in the whole world. Tom calculated the worst case line of sight which covered the globe. Chunking the world up ended with roughly 2500 tiles ranging from 50 kilometers across to a whopping 800km.\nSince our algorithm is \\(O(n^3)\\) where \\(n\\) is the worst case line of sight, small tiles will run in much quicker than 4 minutes, while larger tiles will take much longer than 4 minutes. About 50% of the tiles are under 450km, whereas 50% of the total area of all tiles comes in at 1900 tiles and under 650km.\nTo process all the tiles, we took a stab at a Tom-and-Ryan version of a MapReduce cluster with 5 AMD Turin machines. We called it Atlas, and you can read about it here.\nAll in all, the full world run took 18 hours and cost us a few hundred dollars which is much less than the few hundred thousand that Tom initially estimated.\nThe Final Product Looking for the longest line of sight? Go check it out at https://alltheviews.world and see our curated list of the top ten longest lines of sight. You won’t believe number 3!\nDon’t forget to go play with the interactive map at https://map.alltheviews.world. Click to find the longest line of sight for any point on earth, and zoom to even find the longest line of sight for your country or state!\nIf you would like to take a look at all the code this blog post is about, or have any ideas for improvements, here is the GitHub link for our total viewshed algorithm, CacheTVS.\nAcknowledgements I’d like to acknowledge Tom for being the rock for which all this research was able to take place on top of.\nI’d also like to acknowledge my family and friends for listening to my insane ramblings. They really didn’t know much that was going on until it all came together, and they got to play around with the tool. Thanks for your patience!\nSo long, and thanks for all the fish!\n","wordCount":"6761","inLanguage":"en","datePublished":"2026-02-01T20:10:00-07:00","dateModified":"2026-02-01T20:10:00-07:00","author":[{"@type":"Person","name":"Ryan Berger"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://ryan.berge.rs/posts/total-viewshed-algorithm/"},"publisher":{"@type":"Organization","name":"Ryan Berger's Page","logo":{"@type":"ImageObject","url":"https://ryan.berge.rs/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://ryan.berge.rs/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://ryan.berge.rs/blog/ title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">A Total Viewshed Algorithm to Find the Longest Line of Sight
<span class=entry-hint title=Draft><svg height="35" viewBox="0 -960 960 960" fill="currentColor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h1><div class=post-meta><span title='2026-02-01 20:10:00 -0700 -0700'>February 1, 2026</span>&nbsp;·&nbsp;32 min&nbsp;·&nbsp;Ryan Berger</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#the-total-viewshed-algorithm aria-label="The Total Viewshed Algorithm">The Total Viewshed Algorithm</a><ul><li><a href=#line-of-sight-visibility aria-label="Line of Sight Visibility">Line of Sight Visibility</a></li><li><a href=#the-state-of-the-art-total-viewshed-algorithm aria-label="The State-of-the-Art Total Viewshed Algorithm">The State-of-the-Art Total Viewshed Algorithm</a></li><li><a href=#our-benchmark-viewshed aria-label="Our Benchmark Viewshed">Our Benchmark Viewshed</a></li></ul></li><li><a href=#building-a-cache-efficient-algorithm aria-label="Building A Cache Efficient Algorithm">Building A Cache Efficient Algorithm</a><ul><li><a href=#a-cache-nightmare aria-label="A Cache Nightmare">A Cache Nightmare</a></li><li><a href=#spinning-in-circles aria-label="Spinning In Circles">Spinning In Circles</a></li><li><a href=#the-stars-mostly-align aria-label="The Stars (Mostly) Align">The Stars (Mostly) Align</a></li></ul></li><li><a href=#a-brief-intermission aria-label="A Brief Intermission">A Brief Intermission</a></li><li><a href=#finding-the-longest-line-of-sight-with-cachetvs aria-label="Finding The Longest Line of Sight With CacheTVS">Finding The Longest Line of Sight With CacheTVS</a><ul><li><a href=#multithreading aria-label=Multithreading>Multithreading</a></li><li><a href=#instruction-level-parallelism aria-label="Instruction Level Parallelism">Instruction Level Parallelism</a></li><li><a href=#prefix-sums-and-scans aria-label="Prefix Sums and Scans">Prefix Sums and Scans</a></li><li><a href=#cache-pressure-ain aria-label="Cache Pressure Ain&rsquo;t Gonna Break My Stride">Cache Pressure Ain&rsquo;t Gonna Break My Stride</a></li><li><a href=#simd aria-label=SIMD>SIMD</a><ul><li><a href=#x86-and-ieee754 aria-label="x86 and IEEE754">x86 and IEEE754</a></li></ul></li><li><a href=#parallel-scans aria-label="Parallel Scans">Parallel Scans</a></li><li><a href=#accumulating aria-label=Accumulating>Accumulating</a></li><li><a href=#a-final-benchmark-viewshed-timing aria-label="A Final Benchmark Viewshed Timing">A Final Benchmark Viewshed Timing</a></li></ul></li><li><a href=#a-full-world-run aria-label="A Full World Run">A Full World Run</a><ul><li><a href=#the-final-product aria-label="The Final Product">The Final Product</a></li></ul></li><li><a href=#acknowledgements aria-label=Acknowledgements>Acknowledgements</a></li></ul></div></details></div><div class=post-content><blockquote><p><em>Welcome all readers from the <a href=../lines-of-sight>non-technical lines of sight post</a></em></p></blockquote><p>The past 6 months of almost every moment of my free time has been spent developing an algorithm with my friend
<a href=https://tombh.co.uk>Tom Buckley-Houston</a> to exhaustively prove that we&rsquo;ve found the longest line of sight in the world.
We both felt it was very doable algorithmically, but current options looked extremely computationally intensive.</p><p>Since the inception of the project, through hard work and collaboration, we have been able to speed up the calculations
by hundreds of times, and make it entirely feasible on top-of-the-line CPUs such as the AMD Turin.
Please enjoy the deep dive, and make sure to check out <a href=https://tombh.co.uk/longest-line-of-sight>Tom&rsquo;s sister-blogpost</a>
and <a href=https://alltheviews.world>https://alltheviews.world</a> for the final product!</p><p>As it is truly 6 months worth of information, I&rsquo;ve broken it up into 3 main chunks, with an intermission:</p><ol><li><a href=#the-total-viewshed-algorithm>An introduction</a> to the total viewshed and lines of sight algorithm,
which is required reading for the other two.</li><li><a href=#building-a-cache-efficient-algorithm>Data layout</a> and how that affects performance, and the optimizations
we found to make the most of the CPU cache.</li></ol><blockquote><p><a href=#a-brief-intermission>An intermission</a>.</p></blockquote><ol start=3><li><a href=#finding-the-longest-line-of-sight-with-cachetvs>Finding the longest line of sight</a>, via multithreading, SIMD,
and instruction level parallelism all with the safety of Rust!</li></ol><p>Use these links along with the Table of Contents drop-down above to digest at your leisure!</p><h1 id=the-total-viewshed-algorithm>The Total Viewshed Algorithm<a hidden class=anchor aria-hidden=true href=#the-total-viewshed-algorithm>#</a></h1><p>A <a href=https://en.wikipedia.org/wiki/Viewshed>viewshed</a> is all the area visible from a particular location on the map:</p><figure class=align-center><img loading=lazy src=/lines/cardiff_viewshed.webp#center></figure><p>It also happens to hold the longest line of sight, since it is the furthest
visible point from the observer.</p><p>Traditional viewshed algorithms take Digital Elevation Mappings (DEMs) and calculate the angles pair-wise for all points
and then determine whether there are obstructions. This approach works well for a single viewshed, however, scaling to
more than one runs head-first into cache issues.</p><p>You could imagine if you naively apply this pair-wise computation you end up re-fetching and re-calculating quite a lot.
Tools like <a href=http://pro.arcgis.com/en/pro-app/tool-reference/3d-analyst/viewshed.htm>ArcGIS</a> do single viewshed calculations on the order of minutes, which works just fine for a single viewshed
but makes every point on the planet algorithmically infeasible, so a new solution was needed. We needed a &ldquo;total viewshed&rdquo; algorithm,
not just a single viewshed.</p><p>Enter, the total viewshed algorithm.</p><h2 id=line-of-sight-visibility>Line of Sight Visibility<a hidden class=anchor aria-hidden=true href=#line-of-sight-visibility>#</a></h2><p>At the foundation of the total (or single) viewshed algorithm lies the humble line of sight visibility calculation.
The line of sight visibility is the measure of visibility for some slice of the viewshed, say one
degree, which accumulated makes up a full viewshed.</p><p>Line of sight visibility calculations are entirely boolean (is the point visible to the observer or not) and are entirely
two-dimensional. To make this three-dimensional slice of space two-dimensional, we use an azimuthal projection to
project our observer into a two-dimensional space.</p><figure class=align-center><img loading=lazy src=/lines-technical/observer.png#center alt="Yes, &lsquo;azimuthal projection&rsquo; is just a fancy way of describing the Google Map Guy™&rsquo;s POV"><figcaption><p>Yes, &lsquo;azimuthal projection&rsquo; is just a fancy way of describing the Google Map Guy™&rsquo;s POV</p></figcaption></figure><p>The elevations &ldquo;in front of&rdquo; the observer on the y-axis, distance on the x. The line of sight may lie between
two elevations so an interpolated value is chosen and a &ldquo;band&rdquo; of sight is also chosen, meaning the observer sees
exactly one point at a time.</p><figure class=align-center><img loading=lazy src=/lines-technical/observer_angle.png#center></figure><p>The angle of elevation between two points must also take into account the curvature of the earth,
along with the refraction of light. The equation for adjusting the elevation for both is given by
the following <a href=https://pro.arcgis.com/en/pro-app/3.4/tool-reference/3d-analyst/how-line-of-sight-works.htm>equation</a>:</p><p>$$
E^\prime = E + (D^2(R - 1) / d_{earth}); \newline
$$</p><p>Where \(E^\prime\) is the adjusted elevation, \(D\) is the distance to the point, \(R\) is a refraction coefficient
which has been calculated to be \(\approx.13\), and \(d_{earth}\) is the diameter of the earth in kilometers.</p><p>The angle of elevation, \(\theta\), between a point along the line of sight forms a right triangle. Since adjusted elevation is on
the opposite side of the triangle, while the distance to the point is the adjacent side, \(tan\) will be our friend:
$$
tan(\theta) = (E^\prime - h_{pov}) / D \newline
\theta = tan^{-1}((E^\prime - h_{pov}) / D)
$$</p><p>Where \(h_{pov}\) is the height of the observer.</p><blockquote><p><em><strong>Math Nerd (arc)Tangent</strong>:</em></p><p>For computational purposes we won&rsquo;t actually carry out \(tan^{-1}\). We can get away with this because
it is continuous and monotonically increasing on \((-\infty, \infty)\). This means
\( tan^{-1}(x_1) > tan^{-1}(x_2) \iff x_1 > x_2 \) so the extra computation doesn&rsquo;t give us anything extra.</p></blockquote><p>Once the angles of elevation are laid out, we can determine visibility for each point along the line of sight.
A point is visible to the observer if the angle of elevation between the observer and the point is greater than all
the angles of previous points. The angle between the point of view and itself \(-\infty\) since there is
&ldquo;no angle&rdquo; and we want all angles to be greater than it.</p><figure class=align-center><img loading=lazy src=/lines-technical/prefix_angles.png#center alt="Calculated angles of elevation, along with their respective &lsquo;highest previously seen angle&rsquo;"><figcaption><p>Calculated angles of elevation, along with their respective &lsquo;highest previously seen angle&rsquo;</p></figcaption></figure><p>Here our observer determines visibility at each point by checking to see if the current angle is greater than
the maximum of all previous angles, which is pictured below the previous graphic&rsquo;s angle calculation.</p><p>Rotating this line of sight calculation around for all the terrain within the worst case line of sight for a given point
will give you 360 different bitmaps of which points are visible. You can use those to construct a viewshed.</p><p>Tada!</p><h2 id=the-state-of-the-art-total-viewshed-algorithm>The State-of-the-Art Total Viewshed Algorithm<a hidden class=anchor aria-hidden=true href=#the-state-of-the-art-total-viewshed-algorithm>#</a></h2><p>Now that we have line of sight visibility down, we can move on to the meat and potatoes, the total viewshed.</p><p>There isn&rsquo;t a ton of literature existing for calculating total viewsheds for large maps. However, there are a few
prolific authors in the total viewshed space who have published many papers. Namely, Tabik et al. My friend Tom
read their initial <a href=https://ieeexplore.ieee.org/document/6837455>total viewshed paper</a> back in 2017 while researching
how to find the longest line of sight, which had been a dream of his.</p><p>In the paper, they lay out a solution that attempts to parallelize a single viewshed calculation to calculate a total viewshed.
Their approach makes use of Linear Algebra to find the closest points to a normal vector (that they call the sector)
so they can determine which points to sample along the line of sight visibility calculation. In the paper they call
this &ldquo;sector ordering&rdquo;.</p><figure class=align-center><img loading=lazy src=/lines-technical/sector_distances.png#center></figure><p>Sector distances are not necessarily uniform from point to point (even potentially zig-zagging) along the line
of sight so they must also be kept track of.</p><figure class=align-center><img loading=lazy src=/lines-technical/zigzag.png#center alt="This line of sight zigzags"><figcaption><p>This line of sight zigzags</p></figcaption></figure><p>They construct the line of sight projection using a linked list container like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> node {
</span></span><span style=display:flex><span>    node<span style=color:#f92672>*</span> prev; <span style=color:#75715e>// previous elevation in line of sight
</span></span></span><span style=display:flex><span>    node<span style=color:#f92672>*</span> next; <span style=color:#75715e>// next elevation in line of sight
</span></span></span><span style=display:flex><span>    int16<span style=color:#f92672>*</span> data; <span style=color:#75715e>// elevation data
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> distance; <span style=color:#75715e>// distance from pov
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The linked list elevation data isn&rsquo;t a copy of the elevation data, it is a pointer to it.
This then gets shipped off to a GPU for visibility calculation. The linked list and sector distances get reconstructed
for every line of sight for every point and angle duplicating a ton of work.</p><p>Very quickly Tom found that the linked list is Not A Good Idea™. In fact, the maximum line of sight is always
going to have some upper bound, so we can pre-allocate an array of that size. Rather than pointers, Tom calculated
position-independent offsets into the DEM, which he called &ldquo;deltas&rdquo;.</p><p>Tom also was able to make a parallel array for the sector distance. This way you add your delta to get the elevation,
you use the distance from the sector distance array, and then you are able to calculate the angle to the point along the
line of sight.</p><p>Those offsets stay the same for every angle, so Tom only ever had to calculate them once rather for each point like the
other paper.</p><figure class=align-center><img loading=lazy src=/lines-technical/delta.png#center alt="Deltas are really just vectors you can add to get where you&rsquo;re going"><figcaption><p>Deltas are really just vectors you can add to get where you&rsquo;re going</p></figcaption></figure><p>With deltas, you take your point of view&rsquo;s index, add the delta, and it gives you the index into the DEM of your
next point along your line of sight. Do this for every point for every angle and you have a total viewshed. No linked
list or pointer indirection involved.</p><p>Tom left his improvements on the back burner for 8 years until July 2025 when he started porting it to Rust.</p><h2 id=our-benchmark-viewshed>Our Benchmark Viewshed<a hidden class=anchor aria-hidden=true href=#our-benchmark-viewshed>#</a></h2><p>Since Mount Everest is the tallest point in the world, the viewshed with its peak was a very
attracting benchmark for us. We immediately made it our &ldquo;north star&rdquo;. You&rsquo;ll notice that I through
timings of per-angle benchmarks, <strong>all of them refer to Everest.</strong></p><p>The worst case line of site was estimated to be 670km by Tom, but we wanted it just a tad smaller so we could run faster.
So, we stuck with a nice round 600km. This also happens to be one of the biggest worst case lines of sight in the world,
so if we could get it running fast on Everest, then surely the world would be right around the corner.</p><p>Tom&rsquo;s initial runs showed that running all of Everest took about 12 hours. Our first test runs didn&rsquo;t show any
lines of sight over 400km, confirming 600km was a safe estimate. Once it came time to do the whole world though,
this wouldn&rsquo;t do.</p><blockquote><p>For more on why there&rsquo;s such a gap between the worst case line of sight and the actual longest line of
sight check out <a href=https://tombh.co.uk/packing-world-lines-of-sight>this section</a> in Tom&rsquo;s blogpost.</p></blockquote><p>Tom worried there may be even longer worst case lines of sight, such as 800km. An algorithm that has to check a
DEM which has \(n \times n\) elevations, and checking a total of \(n\) elevations along your line of sight for
360 angles, you are looking at potentially taking almost 2.4x longer with a 1.3x longer worst case line of sight.</p><p>Tom&rsquo;s initial estimates were that this would cost us potentially hundreds of thousands of dollars and many months
of spot instance compute (meaning it could be shut down at any time). This was not feasible for either of our time
or money budgets, and I was certain that we could do better and calculate the whole world.</p><p>Enter, me.</p><h1 id=building-a-cache-efficient-algorithm>Building A Cache Efficient Algorithm<a hidden class=anchor aria-hidden=true href=#building-a-cache-efficient-algorithm>#</a></h1><h2 id=a-cache-nightmare>A Cache Nightmare<a hidden class=anchor aria-hidden=true href=#a-cache-nightmare>#</a></h2><p>After rubbing some braincells together on the problem and re-implementing the algorithm myself, I noticed a complete lack
of cache locality. Tom&rsquo;s total viewshed algorithms may not have to recompute the &ldquo;deltas&rdquo; for each point, but it
is effectively a single viewshed algorithm applied for every point. Not exactly good for having to compute every viewshed.</p><p>The points are not processed in any particular order, meaning that while you are working from
left to right within the DEM, you are likely accessing completely different elevations.</p><figure class=align-center><img loading=lazy src=/lines-technical/diagonal.png#center></figure><p>This effectively benchmarks your processor&rsquo;s prefetcher with the number of cache misses you&rsquo;ll incur, not the FLOPs.</p><p>How bad are these cache misses? Well, the elevation data we have is at a resolution of 100m. For our lower-than-needed
upper bound of 600km for Mount Everest&rsquo;s we are talking 36 million elevations. Those elevations are stored as i16s
totaling ~72MBs. Much bigger than what L3 can fit.</p><p>My mind first went to &ldquo;sorting by lines of sight&rdquo;. Deltas take a single point and get us to the next point, but don&rsquo;t
care about what order you process points in. Since the next point is now in cache, it would be nice to reuse the data
for the next line of sight calculation.</p><p>However, this falls flat on its face very quickly for a very simple reason: a line of sight is not contiguous in terms
of memory. By accessing non-contiguous memory you may be loading <em>some</em> of the data into cache, but most of it is
not being used in the line of sight calculation.</p><figure class=align-center><img loading=lazy src=/lines-technical/cache_waste.png#center alt="All the red bars are the full cache line of points your CPU fetches when asked to load the green points"><figcaption><p>All the red bars are the full cache line of points your CPU fetches when asked to load the green points</p></figcaption></figure><p>In fact, in the worst case, since elevation data is stored as an <code>i16</code> you are wasting 96% of a 64 byte cache line. OUCH.</p><p>With that much data being wasted, I set out to try to guarantee all data accesses for all lines of sight were contiguous,
and wouldn&rsquo;t you have it, all the squinting and rotating my head paid off.</p><h2 id=spinning-in-circles>Spinning In Circles<a hidden class=anchor aria-hidden=true href=#spinning-in-circles>#</a></h2><p>After staring at deltas and their corresponding distances for much too long, the deltas for 45 degrees popped out to me
as particularly interesting. Not only were lines of sight much faster to calculate for 45 degrees, but visualizing the
deltas showed that they create perfectly diagonal lines from the point of view and going across the DEM.
The distances were also entirely uniform between points.</p><p>Since these lines are perfectly straight, why couldn&rsquo;t I make them entirely contiguous in memory and process the lines
of sight from left to right instead of corner to corner?</p><figure class=align-center><img loading=lazy src=/lines-technical/rotated.png#center></figure><p>This looked absolutely too good to be true! Surely rotating the map only works for some points but not all. And maybe
it gets strange at angles that aren&rsquo;t divisible by 45 and the whole idea is dead in the water? Would the distances
be able to stay continuous? After wondering if this was doable or missing points, Tom and I sat down, convinced ourselves
that this was possible and generated this image:</p><figure class=align-center><img loading=lazy src=/lines-technical/logo.png#center alt="A circle seen forming in the center of the DEM from all the rotations"><figcaption><p>A circle seen forming in the center of the DEM from all the rotations</p></figcaption></figure><p>Tom had already noticed that the original authors were only calculating lines of sight internally to the DEM.
When it came to calculating the full line of sight for every point they stopped short, mentioning it as a limitation
of the algorithm. This results in very few full viewsheds actually being valid.</p><p>However, if you have 3x the data padding the tile, all lines of sight will be able to be calculated for lines
of sight for all angles. While messing with rotations, we realized that only 2 times the data is required for computing
the line of sight per angle. Instead of rotating the entire DEM, we only need to rotate a rectangular portion,
which we nick-named the &ldquo;chocolate bar&rdquo;</p><figure class=align-center><img loading=lazy src=/lines-technical/chocolate_bar.png#center alt="A chocolate bar in all its glory"><figcaption><p>A chocolate bar in all its glory</p></figcaption></figure><p>The square tiles were now outliving their usefulness. When rotating the rectangle, it sometimes &ldquo;juts&rdquo; outside
the DEM, meaning we don&rsquo;t have the data for it. We nick-named these &ldquo;dolphins&rdquo; because they create little triangles
when overlaid with the DEM that look like a dolphin&rsquo;s top fin.</p><figure class=align-center><img loading=lazy src=/lines-technical/dolphin.png#center alt="A dolphin fin" width=100%><figcaption><p>A dolphin fin</p></figcaption></figure><p>Dolphins occur because squares don&rsquo;t have infinite rotational symmetry so stuffing a rotated tile back into a square causes
it to be cut off. To fix this, we can just use circular tiles. The total viewshed is still padded with 3x the data,
except it is now 3 times the diameter of the worst-case longest line of sight.</p><p>The deltas and sector distances are dead! Viva la Rotación!</p><h2 id=the-stars-mostly-align>The Stars (Mostly) Align<a hidden class=anchor aria-hidden=true href=#the-stars-mostly-align>#</a></h2><p>Now that we rotate the map, we completely front-load all our cache misses and perfectly align our data for our
line of sight calculations. Of course, this is all unidirectional as we are only calculating the line of sight for all
points at a single angle. This rotation itself incurs roughly a one-second penalty for even the biggest DEMs. A huge win.</p><p>Cutting down the amount of data ends up meaning we can fit multiple widths worth of the DEM into L1 for calculation.
Another HUGE win.</p><p>There is one downside that bears mentioning: when calculating the rotated coordinates for an elevation it may not fall
between a single elevation evenly. You have to interpolate some elevation there so that a line of sight
calculation can be performed and not just have missing data. This is called <em>rasterization</em>.</p><figure class=align-center><img loading=lazy src=/lines-technical/rasterization.png#center alt="A rasterized triangle, courtesy of scratchpixel"><figcaption><p>A rasterized triangle, courtesy of <a href=https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/rasterization-stage.html>scratchpixel</a></p></figcaption></figure><p>We chose the &ldquo;nearest neighbor&rdquo; interpolation algorithm because it is extremely easy to implement and is considered to
be within the acceptable margins of error established in the academic viewshed literature (See Siham Tabik et al. in
<em>Efficient Data Structure and Highly Scalable Algorithm for Total-Viewshed Computation</em>
<a href=https://ieeexplore.ieee.org/document/6837455)>https://ieeexplore.ieee.org/document/6837455)</a>.</p><p>Attempting to make rotation a function mapping coordinates from the unrotated image onto to the rotated one also runs
into trouble. Streaks will be unfilled because it isn&rsquo;t guaranteed there is a one to one mapping of coordinates when
there is rounding involved. Mathematically, we can see this because rotated points aren&rsquo;t guaranteed to be unique
due to \(\lfloor(x, y)\rceil\) meaning this function isn&rsquo;t one to one:</p><p>$$
rotate(x, y, \theta):
\begin{bmatrix}
cos \theta & -sin \theta \\
sin \theta & cos \theta
\end{bmatrix}
\begin{bmatrix}
x \\
y
\end{bmatrix}
$$</p><p>$$
DEM = \{ 0 \le x &lt; DEM_{width}; 0 \le y &lt; DEM_{width} \mid (x, y) \}
$$</p><p>$$
DEM_{rotated} = \{(x, y) \in DEM \mid \lfloor rotate(x, y, \theta) \rceil \}
$$</p><p>$$
DEM \cap DEM_{rotated} \neq DEM
$$</p><p>This is solved by doing an &ldquo;anti rotation&rdquo;. Looping over all the points of the output image, and choosing the closest
coordinate in the input.</p><p>$$
anti\_rotate(x, y, \theta): rotate(x, y, -\theta)
$$</p><p>$$
DEM_{rotated} = [ 0 \le x &lt; DEM_{width}; 0 \le y &lt; DEM_{width} \mid DEM[\lfloor anti\_rotate(x, y, \theta) \rceil] ]
$$</p><p>Now it is guaranteed there&rsquo;s a point in \(DEM_{rotated}\) for every \((x, y)\) but it isn&rsquo;t guaranteed to be unique.
This is fine for our purposes.</p><h1 id=a-brief-intermission>A Brief Intermission<a hidden class=anchor aria-hidden=true href=#a-brief-intermission>#</a></h1><p>Get up, go get a drink of water or coffee, breathe a little. We&rsquo;re through the hardest part!</p><p>Please enjoy this Shiba who is a shop-keeper.<div style=display:flex;justify-content:center><iframe width=560 height=315 src=https://www.youtube.com/embed/E6CcUj2mDbI title="YouTube video player" frameborder=0 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy=strict-origin-when-cross-origin allowfullscreen></iframe></div></p><h1 id=finding-the-longest-line-of-sight-with-cachetvs>Finding The Longest Line of Sight With CacheTVS<a hidden class=anchor aria-hidden=true href=#finding-the-longest-line-of-sight-with-cachetvs>#</a></h1><p>Once we developed the optimal cache setup to guarantee that our calculations are no longer
memory bound, the world became our oyster. A global total viewshed calculation seemed right on our doorstep.</p><p>Initial runs showed that our algorithm ran at about ~120 seconds per angle for Everest with very little optimization,
just straight-line Rust code. This timing means Everest takes 12 hours, but good news, it is single threaded so there&rsquo;s
plenty more to go.</p><p>With the high-level architecture complete we decided to name our algorithm, <em><strong>CacheTVS</strong></em>.</p><p>CacheTVS has three different types of outputs:</p><ul><li>the surface area heatmap,</li><li>the point-by-point longest line of sight,</li><li>the viewshed bitmaps</li></ul><p>The surface area heatmap is an estimate of the visible area from a point of view.</p><p>The point-by-point computation for the line of sight holds the angle and distance of the longest line of sight found.</p><p>The viewshed bitmaps are the boolean visibility computations out to the worst case line of sight for all 360 degrees.</p><p>We mainly only use the first two, as we calculated that storing the viewshed bitmap for Everest would be a few Terabytes
worth of information, and it doesn&rsquo;t actually give us anything extra. The world would be many Petabytes. We really only need a
visualization of how much area each point can see, and of course the longest line of sight.</p><blockquote><p>Also, we personally don&rsquo;t have hard drives big enough :(</p></blockquote><p>In total, we use exactly 8 times the amount of data of a single DEM which is entirely feasible and only around
200GB for the entire world.</p><h2 id=multithreading>Multithreading<a hidden class=anchor aria-hidden=true href=#multithreading>#</a></h2><p>As mentioned previously, all our initial tests were single threaded. Since the total viewshed calculation works
on an angle by angle snapshot of the data, we can already parallelize this by the number of cores what we have,
which for my machine is 8 cores. Because this workload is compute heavy, it doesn&rsquo;t make sense to make use of SMT
since threads will be fighting heavily for compute units.</p><p>To get the new time with 8-way parallelism, we just divide the amount of work, 360 angles, by the amount of cores
and multiply by the number of seconds.</p><p>$$
((360 / 8) * 120\space secs) / 60 \space secs \newline
= ~1.5 \space hrs
$$</p><p>We&rsquo;re under two hours for all of everest!</p><h2 id=instruction-level-parallelism>Instruction Level Parallelism<a hidden class=anchor aria-hidden=true href=#instruction-level-parallelism>#</a></h2><p>With the easy parallelization out of the way, it is time to see if we can squeeze extra parallelism out of our processor.
There are many ways in which a CPU is parallel, not just multi-threading. You also have instruction-level
parallelism along with SIMD. Initially, lets focus on the first. Speaking of, what does our line of sight calculation currently look like?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>line_of_sight</span>(pov_height: <span style=color:#66d9ef>i16</span>, refraction: <span style=color:#66d9ef>f32</span>, elevations: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>i16</span>]) -&gt; (<span style=color:#66d9ef>f32</span>, <span style=color:#66d9ef>f32</span>) { <span style=color:#75715e>// (surface area, distance)
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> highest_angle <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#66d9ef>f32</span>::<span style=color:#66d9ef>INF</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> longest_distance <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span><span style=color:#66d9ef>f32</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> surface_area <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span><span style=color:#66d9ef>f32</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (distance, elevation) <span style=color:#66d9ef>in</span> elevations.enumerate() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// calculate the curve and refraction adjustment
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> curve_and_refraction <span style=color:#f92672>=</span> ((distance.ipow(<span style=color:#ae81ff>2</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>) <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> refraction)) <span style=color:#f92672>/</span> <span style=color:#66d9ef>EARTH_DIAMETER</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> elevation_prime <span style=color:#f92672>=</span> (elevation <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>) <span style=color:#f92672>+</span> curve_and_refraction
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// calculate the &#34;angle&#34; (really a ratio, not arctan)
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> angle <span style=color:#f92672>=</span> (elevation_prime <span style=color:#f92672>-</span> (pov_height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>)) <span style=color:#f92672>/</span> distance
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// as we determined in the beginning, if the angle is higher,
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// then the point along our elevation map is visible.
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>//
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// Add its area to the surface area, and update the longest
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// distance we&#39;ve seen, and set it as the new highest angle
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> angle <span style=color:#f92672>&gt;</span> highest_angle {
</span></span><span style=display:flex><span>            longest_distance <span style=color:#f92672>=</span> distance <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>
</span></span><span style=display:flex><span>            highest_angle <span style=color:#f92672>=</span> angle
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// TAN_ONE_RADIAN comes from the original paper. I&#39;m not
</span></span></span><span style=display:flex><span>            <span style=color:#75715e>// sure that it is correct, but it makes for a decent estimate
</span></span></span><span style=display:flex><span>            surface_area <span style=color:#f92672>+=</span> distance <span style=color:#f92672>*</span> <span style=color:#66d9ef>TAN_ONE_RADIAN</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    (surface_area, longest_distance)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The main performance issues of this loop arise because each iteration depends on the last.</p><p>CPUs work best when the next instruction doesn&rsquo;t depend on the result of any other instruction before it. It uses
<em>instruction pipelining</em> to issue multiple instructions, allowing instructions to work in parallel so long as there
are no inter-instruction dependencies. This is called Instruction Level Parallelism (ILP).</p><figure class=align-center><img loading=lazy src=/lines-technical/pipeline.png#center alt="A 5-stage CPU pipeline courtesy of GeekForGeeks"><figcaption><p>A 5-stage CPU pipeline courtesy of GeekForGeeks</p></figcaption></figure><p>In the case of the line of sight, the computation that is truly independent of any iteration is
the angle computation. It is only based on distance and elevation, not any angle before or after.</p><p>To be able to unshackle it from the loop-carry dependency, we will trade off storing and re-loading it from
memory for extra ILP. Thankfully this all still fits in L1 so the ILP benefits far outweigh the memory cost.</p><p>We can rewrite the loop as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>line_of_sight</span>(pov_height: <span style=color:#66d9ef>i16</span>, refraction: <span style=color:#66d9ef>f32</span>, elevations: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>i16</span>], angle_buf: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> [<span style=color:#66d9ef>f32</span>]) -&gt; (<span style=color:#66d9ef>f32</span>, <span style=color:#66d9ef>f32</span>) { <span style=color:#75715e>// (surface area, distance)
</span></span></span><span style=display:flex><span>    assert_eq(elevations.len(), angle_buf.len())
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (angle, (distance, elevation)) <span style=color:#66d9ef>in</span> zip(angle_buf.iter_mut(), elevations.enumerate()) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// calculate the curve and refraction adjustment
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> curve_and_refraction <span style=color:#f92672>=</span> ((distance.ipow(<span style=color:#ae81ff>2</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>) <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> refraction)) <span style=color:#f92672>/</span> <span style=color:#66d9ef>EARTH_DIAMETER</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> elevation_prime <span style=color:#f92672>=</span> (elevation <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>) <span style=color:#f92672>+</span> curve_and_refraction
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>angle <span style=color:#f92672>=</span> (elevation_prime <span style=color:#f92672>-</span> (pov_height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>)) <span style=color:#f92672>/</span> distance
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> highest_angle <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#66d9ef>f32</span>::<span style=color:#66d9ef>INF</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> longest_distance <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span><span style=color:#66d9ef>f32</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> surface_area <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span><span style=color:#66d9ef>f32</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> angle <span style=color:#66d9ef>in</span> angles {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// as we determined in the beginning, if the angle is higher,
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// then the point along our elevation map is visible.
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>//
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// Add its area to the surface area, and update the longest
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// distance we&#39;ve seen, and set it as the new highest angle
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> angle <span style=color:#f92672>&gt;</span> highest_angle {
</span></span><span style=display:flex><span>            longest_distance <span style=color:#f92672>=</span> distance <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>
</span></span><span style=display:flex><span>            highest_angle <span style=color:#f92672>=</span> angle
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// TAN_ONE_RADIAN comes from the original paper. I&#39;m not
</span></span></span><span style=display:flex><span>            <span style=color:#75715e>// sure that it is correct, but it makes for a decent estimate
</span></span></span><span style=display:flex><span>            surface_area <span style=color:#f92672>+=</span> distance <span style=color:#f92672>*</span> <span style=color:#66d9ef>TAN_ONE_RADIAN</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    (surface_area, longest_distance)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We&rsquo;ve now maximized the ILP of the angle calculation, but the longest line of sight calculation and
surface area calculation still aren&rsquo;t particularly parallel. Let&rsquo;s fix that!</p><h2 id=prefix-sums-and-scans>Prefix Sums and Scans<a hidden class=anchor aria-hidden=true href=#prefix-sums-and-scans>#</a></h2><p>A prefix sum is a computation that takes a list of numbers and maps it to another list
where each element becomes the cumulative sum of all elements before it, hence its name. Here&rsquo;s a sample
implementation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> nums <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> prefix_sum <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> prefix_acc <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (prefix, num) <span style=color:#66d9ef>in</span> zip(prefix_sum.iter_mut(), nums) {
</span></span><span style=display:flex><span>    prefix_acc <span style=color:#f92672>+=</span> num;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>prefix_sum <span style=color:#f92672>=</span> prefix_acc
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Abstractly, a prefix sum is part of a general family of algorithms called an &ldquo;inclusive scan&rdquo;. A scan is an even more general
algorithm that takes a sequence, an associative binary operator, and applies the binary operator to an accumulated value
and yields the newly accumulated value. Rust has this in its standard library with <code>.iter().scan()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> nums <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// yields the same as above
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> prefix_sum <span style=color:#f92672>=</span> nums
</span></span><span style=display:flex><span>    .iter()
</span></span><span style=display:flex><span>    .scan(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>|</span>acc, elem<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>acc <span style=color:#f92672>+=</span> elem;
</span></span><span style=display:flex><span>        Some(<span style=color:#f92672>*</span>acc)
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    .collect()
</span></span></code></pre></div><p>Why do we care about scans? Well, for the real numbers <code>max</code> also happens to be an associative binary operator.</p><p>When we do our visibility calculations, we are comparing the current angle against the <em>highest</em> angle:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>if</span> angle <span style=color:#f92672>&gt;</span> highest_angle {
</span></span><span style=display:flex><span>    longest_distance <span style=color:#f92672>=</span> distance <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>
</span></span><span style=display:flex><span>    highest_angle <span style=color:#f92672>=</span> angle
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    surface_area <span style=color:#f92672>+=</span> distance <span style=color:#f92672>*</span> <span style=color:#66d9ef>TAN_ONE_RADIAN</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If we have a <em>prefix maximum</em> of all the previous angles, then we could independently calculate
whether a particular point is visible by checking to see if <code>angle > prefix_max</code>.</p><p>Fortunately for us, <code>max</code> also happens to be associative for the floating point values that we compute. Generally speaking,
floating point values are not associative due to <code>NaN</code>s and signed zero. We never do any computation that
could yield either result, meaning we are safe to use <code>max</code> associatively.</p><blockquote><p>Interestingly, I&rsquo;m not the first person to think about the application of a prefix maximum for
line of sight visibility calculations. While researching the parallel prefix max, I stumbled upon this interesting
<a href=https://www.cs.cmu.edu/~guyb/papers/Ble93.pdf>paper</a> from all the way back in 1993. The author mentions line of
sight visibility calculations as an off-hand example of a parallelizeable prefix scan:<figure class=align-center><img loading=lazy src=/lines-technical/prefix_scan.png#center alt="Great minds think alike, I guess" width=75%><figcaption><p>Great minds think alike, I guess</p></figcaption></figure></p></blockquote><p>Scans have two variants, inclusive and exclusive. Careful readers may have realized we aren&rsquo;t comparing the
highest angle to the prefix maximum which includes itself (like the above prefix sum). Instead, we are comparing
the angle to the maximum of all <em>previous</em> angles (exclusive of itself). For this reason, we use an exclusive
prefix maximum.</p><p>If we allocate a second buffer and stuff the exclusive prefix maximum in there, our loop iterations
calculating the total surface area become entirely independent of one another. Calculating the longest
line of sight also falls out of our surface area calculation.</p><p>Here&rsquo;s the updated algorithm. I&rsquo;ve broken it out into three separate functions as we now calculate the line of sight in
three discrete steps:</p><ul><li>Angles</li><li>Prefix maximum</li><li>Visibility (surface area and longest line of sight)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>calculate_angles</span>(pov_height: <span style=color:#66d9ef>f32</span>, refraction: <span style=color:#66d9ef>f32</span>, angle_buf: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> [<span style=color:#66d9ef>f32</span>], elevations: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>i16</span>]) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (angle, (distance, elevation)) <span style=color:#66d9ef>in</span> zip(angle_buf.iter_mut(), elevations.enumerate()) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> curve_and_refraction <span style=color:#f92672>=</span> ((distance.ipow(<span style=color:#ae81ff>2</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>) <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> refraction)) <span style=color:#f92672>/</span> <span style=color:#66d9ef>EARTH_DIAMETER</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> elevation_prime <span style=color:#f92672>=</span> (elevation <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>) <span style=color:#f92672>+</span> curve_and_refraction
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>angle <span style=color:#f92672>=</span> (elevation_prime <span style=color:#f92672>-</span> (pov_height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>)) <span style=color:#f92672>/</span> distance
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>prefix_max</span>(prefix_max_buf: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> [<span style=color:#66d9ef>f32</span>], angle_buf: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>f32</span>]) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> highest_seen <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#66d9ef>f32</span>::<span style=color:#66d9ef>INF</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>for</span> (prefix_max, (distance, angle)) <span style=color:#66d9ef>in</span> zip(prefix_max_buf.iter_mut(), angles.enumerate()) {
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>prefix_max <span style=color:#f92672>=</span> highest_seen;
</span></span><span style=display:flex><span>        highest_seen <span style=color:#f92672>=</span> max(<span style=color:#f92672>*</span>prefix_max, highest_seen);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>visibility</span>(angles: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>f32</span>], prefix_max: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>f32</span>]) -&gt; (<span style=color:#66d9ef>f32</span>, <span style=color:#66d9ef>f32</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> longest_distance <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span><span style=color:#66d9ef>f32</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> ((distance, angle), prefix_max) <span style=color:#66d9ef>in</span> zip(angles.enumerate(), prefix_max) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> angle <span style=color:#f92672>&gt;</span> prefix_max {
</span></span><span style=display:flex><span>            surface_area <span style=color:#f92672>+=</span> distance <span style=color:#f92672>*</span> <span style=color:#66d9ef>TAN_ONE_RADIAN</span>
</span></span><span style=display:flex><span>            longest_distance <span style=color:#f92672>=</span> distance
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    (surface_area, longest_distance)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>line_of_sight</span>(
</span></span><span style=display:flex><span>    pov_height: <span style=color:#66d9ef>i16</span>, 
</span></span><span style=display:flex><span>    refraction: <span style=color:#66d9ef>f32</span>,
</span></span><span style=display:flex><span>    elevations: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>i16</span>], 
</span></span><span style=display:flex><span>    angle_buf: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> [<span style=color:#66d9ef>f32</span>], 
</span></span><span style=display:flex><span>    prefix_max_buf: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> [<span style=color:#66d9ef>f32</span>],
</span></span><span style=display:flex><span>) -&gt; (<span style=color:#66d9ef>f32</span>, <span style=color:#66d9ef>f32</span>) { <span style=color:#75715e>// (surface area, distance)
</span></span></span><span style=display:flex><span>    assert_eq(elevations.len(), angle_buf.len())
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    calculate_angles(pov_height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>, refraction, angle_buf, elevations);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    prefix_max(prefix_max_buf, angle_buf);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    visibility(angles, prefix_max)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=cache-pressure-ain>Cache Pressure <a href="https://www.youtube.com/watch?v=B4c_SkROzzo">Ain&rsquo;t Gonna Break My Stride</a><a hidden class=anchor aria-hidden=true href=#cache-pressure-ain>#</a></h2><p>Before parallelizing further, I noticed that our angle calculations redo the same curvature computation over and over.
When you have potentially hundreds of millions of lines of sight to process, that&rsquo;s quite a bit of extra computation. We haven&rsquo;t hit an issue
with cache pressure yet so let&rsquo;s pre-compute the curve and refraction adjustment, and also pre-compute the distances between points.
Tiles generally are all of the same <code>scale</code>, 100m, but we add it in for future use:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// generate the curvature adjustments given the scale, refraction and worst case line of sight, `max_los`.
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>generate_distances</span>(max_los: <span style=color:#66d9ef>usize</span>, refraction: <span style=color:#66d9ef>f32</span>, scale: <span style=color:#66d9ef>f32</span>) -&gt; (Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f32</span><span style=color:#f92672>&gt;</span>, Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f32</span><span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> adjusted_refraction <span style=color:#f92672>=</span> refraction <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (<span style=color:#ae81ff>1</span><span style=color:#f92672>..=</span>max_los)
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>step<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> distance <span style=color:#f92672>=</span> (step <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>) <span style=color:#f92672>*</span> scale;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> adjustment <span style=color:#f92672>=</span> (distance <span style=color:#f92672>*</span> distance <span style=color:#f92672>*</span> adjusted_refraction) <span style=color:#f92672>/</span> <span style=color:#66d9ef>EARTH_DIAMETER</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            (distance, adjustment)
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .unzip()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We now can run this once and keep it out of our angle calculation loop. Nice!</p><blockquote><p>Close enough, welcome back sector distances.</p></blockquote><h2 id=simd>SIMD<a hidden class=anchor aria-hidden=true href=#simd>#</a></h2><p>We&rsquo;ve almost squeezed every little bit of ILP out of our algorithm, so now is the time to talk about
another type of parallelism. SIMD.</p><p>SIMD stands for &ldquo;Single Instruction Multiple Data&rdquo;. SIMD widens registers by multiple times the width
of data, say 8 <code>f32</code>s, and allows a single instruction to be issued to do computation on all elements at once.</p><p>Because of the parallel nature of our computation, we are a good fit for rewriting the algorithm in SIMD. Instead of calculating
a single angle at a time, we can calculate 8 at a time on my x86 machine - which has AVX2 - and as we&rsquo;ll see later, up to 16 at a time on
AVX-512 machines.</p><p>Rust currently has an unstable nightly feature called &ldquo;portable SIMD&rdquo; which lets us abstract over the hardware architecture,
which will work well for our most basic computations.</p><p>Trivially, we can use portable SIMD to widen both our angle and longest line of sight computations. Check it out:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// requires #![feature(portable_simd)]
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::simd::prelude::SimdFloat <span style=color:#66d9ef>as</span> _;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::simd::{LaneCount, Simd, SupportedLaneCount};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// fancy itertools macro that lets us zip multiple iterators into one big unnested tuple
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> itertools::izip;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>calculate_angles</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>VECTOR_WIDTH</span>: <span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>    pov_height: <span style=color:#66d9ef>f32</span>, 
</span></span><span style=display:flex><span>    angles_out: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> [<span style=color:#66d9ef>f32</span>], 
</span></span><span style=display:flex><span>    elevations, distances, adjustments) 
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span> 
</span></span><span style=display:flex><span>    LaneCount<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>VECTOR_WIDTH</span><span style=color:#f92672>&gt;</span> : <span style=color:#a6e22e>SupportedLaneCount</span>   
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    assert(elevations.len().is_multiple_of(<span style=color:#66d9ef>VECTOR_WIDTH</span>));
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// turn a &amp;[f32] into a &amp;[[f32; VECTOR_WIDTH]]. The r.h.s of the assignment
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// is the portion that doesn&#39;t fit into VECTOR_WIDTH, but we can ignore it since
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// the length of the slice is asserted to be a multiple of VECTOR_WIDTH
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (vector_angles, _) <span style=color:#f92672>=</span> angles_out.as_chunks_mut::<span style=color:#f92672>&lt;</span>{ <span style=color:#66d9ef>VECTOR_WIDTH</span> }<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (vector_elevations, _) <span style=color:#f92672>=</span> elevations.as_chunks::<span style=color:#f92672>&lt;</span>{ <span style=color:#66d9ef>VECTOR_WIDTH</span> }<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (vector_adjustments, _) <span style=color:#f92672>=</span> adjustments.as_chunks::<span style=color:#f92672>&lt;</span>{ <span style=color:#66d9ef>VECTOR_WIDTH</span> }<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (vector_distances, _) <span style=color:#f92672>=</span> distances.as_chunks::<span style=color:#f92672>&lt;</span>{ <span style=color:#66d9ef>VECTOR_WIDTH</span> }<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (angle_out, <span style=color:#f92672>&amp;</span>elevation, <span style=color:#f92672>&amp;</span>distance, <span style=color:#f92672>&amp;</span>adjustment) <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>izip!</span>(
</span></span><span style=display:flex><span>        vector_angles.iter_mut(),
</span></span><span style=display:flex><span>        vector_elevations.iter(),
</span></span><span style=display:flex><span>        vector_distances.iter(),
</span></span><span style=display:flex><span>        vector_adjustments.iter()
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> elevation_f32: <span style=color:#a6e22e>Simd</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f32</span>, { <span style=color:#66d9ef>VECTOR_WIDTH</span> }<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Simd::from(elevation).cast();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> elevation_prime <span style=color:#f92672>=</span> elevation_f32 <span style=color:#f92672>+</span> Simd::from_array(adjustment);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> res <span style=color:#f92672>=</span> (elevation_prime <span style=color:#f92672>-</span> Simd::splat(pov_height)) <span style=color:#f92672>/</span> Simd::from_array(distance);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        res.copy_to_slice(angle_out);
</span></span><span style=display:flex><span>    }    
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>visibility</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>VECTOR_WIDTH</span>: <span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>(angles: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>f32</span>], prefix_max: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>f32</span>], distances: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>f32</span>]) -&gt; (<span style=color:#66d9ef>f32</span>, <span style=color:#66d9ef>f32</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span> 
</span></span><span style=display:flex><span>    LaneCount<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>VECTOR_WIDTH</span><span style=color:#f92672>&gt;</span> : <span style=color:#a6e22e>SupportedLaneCount</span>   
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    assert(angles.len().is_multiple_of(<span style=color:#66d9ef>VECTOR_WIDTH</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (vector_angles, _) <span style=color:#f92672>=</span> angles.as_chunks::<span style=color:#f92672>&lt;</span>{ <span style=color:#66d9ef>VECTOR_WIDTH</span> }<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (vector_prefix, _) <span style=color:#f92672>=</span> prefix_max.as_chunks::<span style=color:#f92672>&lt;</span>{ <span style=color:#66d9ef>VECTOR_WIDTH</span> }<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (vector_distances, _) <span style=color:#f92672>=</span> distances.as_chunks::<span style=color:#f92672>&lt;</span>{ <span style=color:#66d9ef>VECTOR_WIDTH</span> }<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (simd_area, simd_longest_distance) <span style=color:#f92672>=</span> izip(angles, distances, prefix_max)
</span></span><span style=display:flex><span>        .fold((Simd::splat(<span style=color:#ae81ff>0.0</span><span style=color:#66d9ef>f32</span>), Simd::splat(<span style=color:#ae81ff>0.0</span><span style=color:#66d9ef>f32</span>)), <span style=color:#f92672>|</span>((acc_area, acc_distances), (angle, distance, prefix_max)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> mask <span style=color:#f92672>=</span> angle.simd_gt(prefix_max);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// if we don&#39;t have _any_ elements, then why carry out the rest of the computation?
</span></span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>mask.any() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> (acc_area, acc_distances);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> selected_distances <span style=color:#f92672>=</span> mask.select(distance, Simd::splat(<span style=color:#ae81ff>0.0</span><span style=color:#66d9ef>f32</span>));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> surface_area <span style=color:#f92672>=</span> selected_distances <span style=color:#f92672>*</span> Simd::splat(<span style=color:#66d9ef>TAN_ONE_RADIAN</span>);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            (acc_area <span style=color:#f92672>+</span> surface_area, acc_distances.simd_max(selected_distances))
</span></span><span style=display:flex><span>        }<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    (simd_area.reduce_sum(), simd_longest_distance.reduce_max())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Programming with SIMD is a very different way of thinking because as you may notice, there are no conditionals.
Instead, each element is compared pairwise with each other to create a &ldquo;mask&rdquo;. Then, you use
that mask to &ldquo;select&rdquo; which elements you want to use for true (the distances) and which to use
for false (zero).</p><p>Rust has some interesting codegen for the <code>!mask.any()</code> that I haven&rsquo;t fully grokked, so I&rsquo;ll leave it for a second blog
post. Suffice it to say that it still uses all vector instructions, and is able to shave 10% off of our time.
If no points within the 8-wide vector are visible (which is very common), there&rsquo;s no reason to do any other calculation,
so there&rsquo;s at least some intuition as to why it is faster.</p><h3 id=x86-and-ieee754>x86 and IEEE754<a hidden class=anchor aria-hidden=true href=#x86-and-ieee754>#</a></h3><p>Rust strives to be a safe language, so all float computations are done <em>without</em> the fastmath flags. Enabling the fastmath
flags in Rust is annoying, and also not <a href=https://simonbyrne.github.io/notes/fastmath/>recommended for various other reasons</a>.
One reason why you might want to turn on fastmath flags is that at least on x86, some instructions such as
comparisons and floating point maximums end up generating a lot of extra instructions to comply with IEEE floating point
standards because guess what: Intel&rsquo;s instructions don&rsquo;t.</p><p>For this project, we actually don&rsquo;t care a ton about the IEEE standard for comparison or maximum as we aren&rsquo;t
generating any <code>NaN</code>s or signed zero. For x86 we implement <code>max</code> with the <code>_mm_max_ps</code> intrinsic and implement greater than with <code>_mm_gt_ps</code>. No extra instructions.</p><p>This gets more important in our next section because we are going to make use of the <code>max</code> instruction quite a bit,
and we need to make sure the minimal number of instructions are generated. It&rsquo;s all to help us stop avoiding the SIMD
elephant in the room: the prefix maximum calculation.</p><h2 id=parallel-scans>Parallel Scans<a hidden class=anchor aria-hidden=true href=#parallel-scans>#</a></h2><p>Calculating the prefix maximum with multiple threads would induce a huge amount of overhead for a small amount
of work, so instead we want to parallelize our prefix maximum via SIMD. The level of parallelism we get out of
the algorithm will be from clearing up the instruction pipeliner and keeping the carried dependencies minimal.</p><p>Because <code>max</code> is associative, we can calculate the prefix maximum for all the angles that fit within a
single SIMD register, keeping all calculations independent of one another and make ILP go brrr.
Then we loop back over the data to propagate the maximum of each through the data. A common pattern you may be
picking up on.</p><p>Onto an example.</p><p>Let&rsquo;s say we have the following angles in two 4-wide registers.</p><pre tabindex=0><code>[1, -1, 2, -2], [3, -3, 4, -4]
</code></pre><p>We can calculate the prefix max of the first register by shifting in an identity element - in our case <code>-f32::INF</code>
since <code>max(x, -f32::INF) = x</code> - and applying our binary operator <code>max</code>. Then we take the result of that and shift in
two identity elements to finish calculating the prefix max in-place:</p><pre tabindex=0><code>max([   1,   -1,  2, -2],
    [-INF,    1, -1,  2])
= [1, max(-1, 1), max(2, -1), max(-2, -1)]
</code></pre><p>Then reuse that for the next in-place prefix max:</p><pre tabindex=0><code>max([   1,  max(-1, 1), max(2, -1), max(-2, -1)], ; &lt;- First iteration
    [-INF,        -INF,          1, max(1,  -1)]) ;  &lt;- First iteration, shifted twice
= [1, max(-1, 1), max(max(2, -1), 1), max(max(-2, -1), max(1, -1))]
= [1, 1, 2, 2]
</code></pre><p>We do the same for the second register, independently:</p><pre tabindex=0><code>max([   3,   -3,  4, -4],
    [-INF,    3, -3,  4])
= [3, max(-3, 3), max(4, -3), max(-4, 4)]
</code></pre><p>Which needs to be reused for the next in-place prefix max:</p><pre tabindex=0><code>max([   3,  max(-3, 3), max(4, -3), max(-4, 4)],
    [-INF,        -INF,          3, max(1, -1)]
= [3, 3, 4, 4]
</code></pre><p>Now, we can take the maximum of the first register, which is always the last element, and splat it across a whole SIMD
register, then call <code>max</code> with it and the second register to complete the process:</p><pre tabindex=0><code>max([3, 3, 4, 4],
    [2, 2, 2, 2])
= [3, 3, 4, 4]
</code></pre><p>No change here. But as you can see, associativity is what lets us do this prefix maximum calculation in-place
and lets us only do \(log_2(4) = 2\) calls to <code>max</code>. When we use 8 or 16 wide registers it is still \(log_2\),
so only a modest increase of one or two extra shifts. It also saves us from having to compute something
like <code>max(max(max(1, -1), 2), -2)</code> which contains a computational dependency.</p><p>When it comes to accumulating the max from previous vectors to the next ones, we just keep an accumulated maximum
that we apply to each vector, completing the full scan and cementing our prefix maximum of all elements:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> local_acc <span style=color:#f92672>=</span> Simd::splat(highest);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> prefix <span style=color:#66d9ef>in</span> vector_prefix {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cur_prefix: <span style=color:#a6e22e>f32x4</span> <span style=color:#f92672>=</span> Simd::from(<span style=color:#f92672>*</span>prefix);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// get the highest form the current vector
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cur_max: <span style=color:#a6e22e>f32x4</span> <span style=color:#f92672>=</span> Simd::splat(cur_prefix[<span style=color:#ae81ff>3</span>]);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// apply the accumulator to the current vector and store it back
</span></span></span><span style=display:flex><span>    _mm_maxps(local_acc, cur_prefix).copy_to_slice(prefix);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// make sure the accumulator holds the result of max(cur_prefix[3], local_acc)
</span></span></span><span style=display:flex><span>    local_acc <span style=color:#f92672>=</span> _mm_maxps(local_acc, cur_max);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There&rsquo;s lots more details and not enough space, so if you are interested in the nitty-gritty, you can take a look at
<a href=https://github.com/AllTheLines/CacheTVS/blob/1bcc17c68114398209f027339bd81e810e6cf8c3/crates/total-viewsheds/src/cpu/vector_intrinsics.rs#L173>the implementation</a>
or take a look at <a href=https://en.algorithmica.org/hpc/algorithms/prefix/>this website</a> or <a href=https://www.adms-conf.org/2020-camera-ready/ADMS20_05.pdf>this paper</a>
which were great guides.</p><h2 id=accumulating>Accumulating<a hidden class=anchor aria-hidden=true href=#accumulating>#</a></h2><p>Now that we are able to calculate the longest line of sight for a given point, we need to do this for every point on
the map. Since we also only go in a single direction, we need to run that for every angle.</p><p>As cores finish up doing their single angle heatmap and line of sight calculation, we simply accumulate their results
into a single &ldquo;final map&rdquo;. At the end, the map accumulates data for all 360 degrees and we&rsquo;re done! We have a total viewshed!</p><blockquote><p>It should be noted that there are a good number of cores that get wasted when running with a core count
that doesn&rsquo;t evenly divide 360. Cores idling waiting for the next angle which doesn&rsquo;t come. This matters for runs
bigger than a single tile - but we leave this as future work.</p></blockquote><h2 id=a-final-benchmark-viewshed-timing>A Final Benchmark Viewshed Timing<a hidden class=anchor aria-hidden=true href=#a-final-benchmark-viewshed-timing>#</a></h2><p>After implementing all of the above optimizations and absolutely squeezing the rock as hard as I could,
water did in fact come out. We took Everest&rsquo;s computation from 120 seconds an angle, down to:</p><p>DRUM ROLL PLEASE</p><p><em><strong>75 seconds per angle.</strong></em></p><p>Astounding. This brought us down to 57 minutes for all of Everest on my 8 core machine.
Every little bit of optimization and tuning brought us here, and it was because of the hard work
we put in that we were getting very close to something usable for a world run. There was one last thing that was
holding me back: AVX-512.</p><p>Very, very recently, AMD released its Turin line of processor which has full AVX-512F support. Which means rather
than having AVX-512 be two AVX2 calculations in a trench-coat, it is a first-class citizen. Renting a top of the line AMD
Turin and our use of const generics and portable SIMD implementation let us seamlessly turn on support for a
16-wide angle calculation, prefix max, and longest line of sight calculation. Enabling it <em>halved</em> the time per angle,
cutting down the calculation to an average of 35 seconds per angle.</p><p>Using the Turins also unlocked a huge number of extra cores. I found that 48 cores was the sweet spot for our algorithm.
Now instead of taking an hour, with 48 cores and AVX512, we were taking 4 minutes for all of Everest. <strong>ALL OF EVEREST</strong>.
This is a 160x speedup over the initial GPU algorithm.</p><h1 id=a-full-world-run>A Full World Run<a hidden class=anchor aria-hidden=true href=#a-full-world-run>#</a></h1><p>Now that we were confident that we had the quickest algorithm we could think up, it was time to run the longest line
of sight algorithm for every tile in the whole world. Tom <a href=%5Bhere%5D(https://tombh.co.uk/packing-world-lines-of-sight)>calculated</a>
the worst case line of sight which covered the globe. Chunking the world up ended with roughly 2500 tiles ranging
from 50 kilometers across to a whopping 800km.</p><p>Since our algorithm is \(O(n^3)\) where \(n\) is the worst case line of sight, small tiles will run in much quicker than
4 minutes, while larger tiles will take <em>much</em> longer than 4 minutes. About 50% of the tiles are under 450km, whereas
50% of the total area of all tiles comes in at 1900 tiles and under 650km.</p><p>To process all the tiles, we took a stab at a Tom-and-Ryan version of a <a href=https://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf>MapReduce</a>
cluster with 5 AMD Turin machines. We called it Atlas, and you can read about it <a href=https://tombh.co.uk/longest-line-of-sight#atlas-the-automater>here</a>.</p><p>All in all, the full world run took 18 hours and cost us a few hundred dollars which is much less than the
few hundred thousand that Tom initially estimated.</p><h2 id=the-final-product>The Final Product<a hidden class=anchor aria-hidden=true href=#the-final-product>#</a></h2><p>Looking for the longest line of sight? Go check it out at <a href=https://alltheviews.world>https://alltheviews.world</a> and see
our curated list of the top ten longest lines of sight. You won&rsquo;t believe number 3!</p><p>Don&rsquo;t forget to go play with the interactive map at <a href=https://mapalltheviews.world>https://map.alltheviews.world</a>. Click
to find the longest line of sight for any point on earth, and zoom to even find the longest line of sight for your country or state!</p><p>If you would like to take a look at all the code this blog post is about, or have any ideas for improvements, here is the
GitHub link for our total viewshed algorithm, <a href=https://github.com/AllTheViews/CacheTVS>CacheTVS</a>.</p><h1 id=acknowledgements>Acknowledgements<a hidden class=anchor aria-hidden=true href=#acknowledgements>#</a></h1><p>I&rsquo;d like to acknowledge Tom for being the rock for which all this research was able to take place on top of.</p><p>I&rsquo;d also like to acknowledge my family and friends for listening to my insane ramblings. They really didn&rsquo;t know
much that was going on until it all came together, and they got to play around with the tool. Thanks for your patience!</p><p>So long, and thanks for all the fish!</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ryan.berge.rs/>Ryan Berger's Page</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>