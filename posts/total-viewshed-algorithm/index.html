<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>A Total Viewshed Algorithm to Find the Longest Line of Sight | Ryan Berger's Page</title><meta name=keywords content><meta name=description content="
Welcome all readers from the non-technical lines of sight post

The past 6 months of almost every moment of my free time has been spent developing an algorithm with my friend
Tom Buckley-Houston to exhaustively prove that we&rsquo;ve found the longest line of sight in the world. We both felt it was very
doable algorithmically, but current options looked extremely computationally intensive.
Since the inception of the project, through hard work and collaboration we have been able to speed up the calculations
by hundreds of times, and make it entirely feasible on top-of-the-line CPUs such as the AMD Turin.
Please enjoy the deep dive, and make sure to check out Tom&rsquo;s sister blogpost
and https://alltheviews.world for the final product!"><meta name=author content="Ryan Berger"><link rel=canonical href=https://ryan.berge.rs/posts/total-viewshed-algorithm/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://ryan.berge.rs/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://ryan.berge.rs/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ryan.berge.rs/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://ryan.berge.rs/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://ryan.berge.rs/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ryan.berge.rs/posts/total-viewshed-algorithm/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:url" content="https://ryan.berge.rs/posts/total-viewshed-algorithm/"><meta property="og:site_name" content="Ryan Berger's Page"><meta property="og:title" content="A Total Viewshed Algorithm to Find the Longest Line of Sight"><meta property="og:description" content=" Welcome all readers from the non-technical lines of sight post
The past 6 months of almost every moment of my free time has been spent developing an algorithm with my friend Tom Buckley-Houston to exhaustively prove that we’ve found the longest line of sight in the world. We both felt it was very doable algorithmically, but current options looked extremely computationally intensive.
Since the inception of the project, through hard work and collaboration we have been able to speed up the calculations by hundreds of times, and make it entirely feasible on top-of-the-line CPUs such as the AMD Turin. Please enjoy the deep dive, and make sure to check out Tom’s sister blogpost and https://alltheviews.world for the final product!"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-01T20:10:00-07:00"><meta property="article:modified_time" content="2026-02-01T20:10:00-07:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="A Total Viewshed Algorithm to Find the Longest Line of Sight"><meta name=twitter:description content="
Welcome all readers from the non-technical lines of sight post

The past 6 months of almost every moment of my free time has been spent developing an algorithm with my friend
Tom Buckley-Houston to exhaustively prove that we&rsquo;ve found the longest line of sight in the world. We both felt it was very
doable algorithmically, but current options looked extremely computationally intensive.
Since the inception of the project, through hard work and collaboration we have been able to speed up the calculations
by hundreds of times, and make it entirely feasible on top-of-the-line CPUs such as the AMD Turin.
Please enjoy the deep dive, and make sure to check out Tom&rsquo;s sister blogpost
and https://alltheviews.world for the final product!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ryan.berge.rs/posts/"},{"@type":"ListItem","position":2,"name":"A Total Viewshed Algorithm to Find the Longest Line of Sight","item":"https://ryan.berge.rs/posts/total-viewshed-algorithm/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A Total Viewshed Algorithm to Find the Longest Line of Sight","name":"A Total Viewshed Algorithm to Find the Longest Line of Sight","description":" Welcome all readers from the non-technical lines of sight post\nThe past 6 months of almost every moment of my free time has been spent developing an algorithm with my friend Tom Buckley-Houston to exhaustively prove that we\u0026rsquo;ve found the longest line of sight in the world. We both felt it was very doable algorithmically, but current options looked extremely computationally intensive.\nSince the inception of the project, through hard work and collaboration we have been able to speed up the calculations by hundreds of times, and make it entirely feasible on top-of-the-line CPUs such as the AMD Turin. Please enjoy the deep dive, and make sure to check out Tom\u0026rsquo;s sister blogpost and https://alltheviews.world for the final product!\n","keywords":[],"articleBody":" Welcome all readers from the non-technical lines of sight post\nThe past 6 months of almost every moment of my free time has been spent developing an algorithm with my friend Tom Buckley-Houston to exhaustively prove that we’ve found the longest line of sight in the world. We both felt it was very doable algorithmically, but current options looked extremely computationally intensive.\nSince the inception of the project, through hard work and collaboration we have been able to speed up the calculations by hundreds of times, and make it entirely feasible on top-of-the-line CPUs such as the AMD Turin. Please enjoy the deep dive, and make sure to check out Tom’s sister blogpost and https://alltheviews.world for the final product!\nThe Total Viewshed Algorithm A viewshed is all the area visible from a particular location on the map:\nIt also happens to hold the longest line of sight, since it is the furthest visible point from the observer.\nTraditional viewshed algorithms take Digital Elevation Mappings (DEMs) and calculate the angles pair-wise for all points and then determine whether there are obstructions. This approach works well for a single viewshed, however, scaling to more than one runs head-first into cache issues.\nYou could imagine if you naively apply this pair-wise computation you end up re-fetching and re-calculating quite a lot. Tools like ArcGIS do single viewshed calculations on the order of minutes, which works just fine for a single viewshed but makes every point on the planet algorithmically infeasible, so a new solution was needed. We needed a “total viewshed” algorithm, not just a single viewshed.\nEnter, the total viewshed algorithm.\nLine of Sight Visibility At the foundation of the total (or single) viewshed algorithm lies the humble line of sight visibility calculation. The line of sight visibility is the measure of visibility for some slice of the viewshed, say one degree, which accumulated makes up a full viewshed.\nLine of sight visibility calculations are entirely boolean (is the point visible to the observer or not) and are entirely two-dimensional. To make this three-dimensional slice of space two-dimensional, we use an azimuthal projection to project our observer into a two-dimensional space.\n(INSERT GRAPHIC OF OBSERVER)\nThe elevations “in front of” the observer on the y-axis, distance on the x. The line of sight may lie between two elevations so an interpolated value is chosen and a “band” of sight is also chosen, meaning the observer sees exactly one point at a time.\n(INSERT ANGLE GRAPHIC)\nThe angle of elevation between two points must also take into account the curvature of the earth, along with the refraction of light. The equation for the adjusted elevation is given by the following equation [1]:\n$$ E^\\prime = E + (D^2(R - 1) / d_{earth}); \\newline $$\nWhere \\(E^\\prime\\) is the adjusted elevation, \\(D\\) is the distance to the point, \\(R\\) is a refraction coefficient which has been calculated to be \\(\\approx.13\\), and \\(d_{earth}\\) is the diameter of the earth in kilometers.\nThe angle of elevation, \\(\\theta\\), between a point along the line of sight forms a right triangle. Since adjusted elevation is on the opposite side of the triangle, while the distance to the point is the adjacent side, \\(tan\\) will be our friend: $$ tan(\\theta) = (E^\\prime - h_{pov}) / D \\newline \\theta = tan^{-1}((E^\\prime - h_{pov}) / D) $$\nWhere \\(h_{pov}\\) is the height of the observer.\nMath Nerd (arc)Tangent:\nFor computational purposes we won’t actually carry out \\(tan^{-1}\\). We can get away with this because it is continuous and monotonically increasing on \\((-\\infty, \\infty)\\). This means \\( tan^{-1}(x_1) \u003e tan^{-1}(x_2) \\iff x_1 \u003e x_2 \\) so the extra computation doesn’t get us anywhere\nOnce the elevations are laid out, we can determine visibility for each point along the line of sight. A point is visible to the observer if the angle of elevation between the observer and the point is greater than all the previous angles of elevation of closer points. The angle between the point of view and itself \\(-\\infty\\) since there is “no angle” and we want all angles to be greater than it.\n(INSERT PREFIX MAX GRAPHIC)\nRotating this line of sight calculation around for a point for all 360 degrees will give you 360 different bitmaps of which points are visible, which you can then use to construct a viewshed. Tada!\nTotal Viewsheds Now that we have line of sight visibility down, we can move on to the meat, the total viewshed.\nThere isn’t a ton of literature existing for calculating total viewsheds for large maps. However, there are a few prolific authors in the total viewshed space who have published many papers namely Tabik et al. My friend Tom read their initial total viewshed paper back in 2020 while researching how to find the longest line of sight, which had been a dream of his.\nIn the paper, they lay out a solution that attempts to parallelize a single viewshed calculation to calculate a total viewshed. Their approach makes use of Linear Algebra to find the closest points to a normal vector (that they call the sector) so they can determine which points to sample along the line of sight visibility calculation. In the paper they call this “sector ordering”.\n(INSERT GRAPHIC ABOUT SECTOR DISTANCES)\nSector distances are not necessarily uniform from point to point (effectively making a potential zigzag) along the line of sight so they must also be kept track of.\n(INSERT GRAPHIC ABOUT ZIGZAG)\nThey construct the line of sight projection using a linked list container like so:\nstruct node { node* prev; // previous elevation in line of sight node* next; // next elevation in line of sight int16* data; // elevation data float distance; // distance from pov } The linked list elevation data isn’t a copy of the elevation data, it is a pointer to it. This then gets shipped off to a GPU for visibility calculation. The linked list gets reconstructed for every line of sight for every point and angle duplicating a ton of work.\nVery quickly Tom found that the linked list is Not A Good Idea™. In fact, the maximum line of sight is always going to have some upper bound, so we can pre-allocate an array of that size. Rather than pointers, Tom calculated position-independent offsets into the DEM, which he called “deltas”.\nTom also was able to make a parallel array for the sector distance. This way you add your delta to get the elevation, you use the distance from the sector distance array, and then you are able to calculate the angle to the point along the line of sight.\nThose offsets stay the same for every angle, so Tom only ever had to calculate them once rather for each point (? TOM ?) like the paper.\n(INSERT DELTA GRAPHIC)\nWith deltas, you take your point of view’s index, add the delta, and it gives you the index into the DEM of your next point corresponding to your projected line of sight for that angle. Do this for every point for every angle and you have a total viewshed. No linked list or pointers involved.\nTom left his improvements on the back burner for a few years until July 2025 when he started porting it to Rust.\nCrazy Initial Estimates Tom’s initial runs showed that running all of Everest took about 12 hours at a measly 600km worst case line of sight. Tom theorized that the actual worst case line of sight was 800km, which meant that with an algorithm that has to check a DEM which has \\(n \\times n\\) elevations, and you check a total of \\(n\\) elevations along your line of sight for 360 angles, you are looking at potentially taking almost 2.4x longer with a 1.3x longer worst case line of sight.\nTom’s initial estimates were that this would cost us potentially hundreds of thousands of dollars and many months of spot instance compute (meaning it could be shut down at any time). This was not feasible for either of our time or money budgets, and I was certain that we could do better and calculate the whole world.\nDown the Rabbithole After rubbing some braincells together on the problem and re-implementing the algorithm myself, I noticed a complete lack of cache locality. Tom’s total viewshed algorithms may not have to recompute the “deltas” for each point, but it is effectively a single viewshed algorithm applied for every point. Not exactly good for having to compute every viewshed.\nThe points are not processed in any particular order, meaning that while you are working from left to right within the DEM, you are likely accessing completely different elevations.\n(INSERT GRAPHIC OF DIAGONAL 45 DEGREE)\nThis effectively benchmarks your processors prefetcher with the number of cache misses you’ll incur, not the line of sight calculation.\nHow bad are these cache misses? Well, the elevation data we have is at a resolution of 100m. For our lower-than-needed upper bound of 600km for Mount Everest’s we are talking 36 million elevations. Those elevations are stored as i16s totaling ~72MBs. Much bigger than what L3 can fit.\nSorting By Lines of Sight My mind first went to “sorting by lines of sight”. Deltas take a single point and get us to the next point, but don’t care about what order your process points in. Since the next point is now in cache, it would be nice to reuse the data for the next line of sight calculation.\nHowever, this falls flat on its face very quickly for a very simple reason: a line of sight is not contiguous in terms of memory. By accessing non-contiguous memory you may be loading some of the data into cache, but most of it is not being used in the line of sight calculation.\n(INSERT CACHE WASTE)\nIn fact, in the worst case since elevation data is stored as an i16 you are wasting 96% of a 64 byte cache line. OUCH.\nWith that much data being wasted, I set out to try guarantee all data accesses for all lines of sight were contiguous, and wouldn’t you have it, all the squinting and rotating my head paid off.\nSpinning In Circles After staring at deltas and their corresponding distances for much too long, the deltas for 45 degrees popped out as me as particularly interesting. Not only were lines of sight much faster to calculate for 45 degrees, but visualizing the deltas showed that they create perfectly diagonal lines from the point of view and going across the DEM. The distances were also entirely uniform between points.\n(INSERT DIAGONAL LINES)\nSince these lines are perfectly straight, why couldn’t I make them entirely contiguous in memory and process the lines of sight from left to right instead of corner to corner?\n(INSERT ROTATED SQUARE)\nThis looked absolutely too good to be true! Surely rotating the map only works for some points but not all. And maybe it gets strange at angles that aren’t divisible by 45 and the whole idea is dead in the water? Would the distances be able to stay continuous? After wondering if this was doable or missing points, Tom and I sat down and generated this image:\n(INSERT ROTATED LOGO)\nTom had already noticed that the original authors were only calculating lines of sight internally to the viewshed. When it came to calculating the full line of sight for every point they stopped short, mentioning it as a limitation of the algorithm.\nHowever, if you have 3x the data padding the tile, all lines of sight will be able to be calculated for lines of sight for all angles. While messing with rotations, we realized that only 2 times the data is required for computing the line of sight per angle. Instead of rotating the enitre DEM, we only need to rotate a rectangular portion, which we nick-named the “chocolate bar”\n(INSERT CHOCOLATE BAR)\nThe square tiles were now outliving their usefulness. When rotating the rectangle, it sometimes “juts” outside the DEM, meaning we don’t have the data for it. We nick-named these “dolphins” because they create little triangles when overlaid with the DEM.\n(INSERT DOLPHINS)\nDolphins occur because squares don’t have infinite rotational symmetry so stuffing a rotated tile back into a square causes it to be cut off. To fix this, we can just use circular tiles. The total viewshed is still padded with 3x the data, except it is now 3 times the diameter of the worst-case longest line of sight.\nThe deltas and sector distances are dead! Viva la Rotación!\nThe Stars (Mostly) Align Now that we rotate the map, we completely front-load all all our cache misses and perfectly align our data for our one-direction line of sight calculations. This all incurs only a one-second penalty for even the biggest DEMs. A huge win.\nCutting down the amount of data ends up meaning we can fit multiple widths worth of the DEM into L1 for calculation. Another HUGE win.\nThere is one downside that bears mentioning: when calculating the rotated coordinates for an elevation it may not fall between a single elevation evenly. You have to choose interpolate some elevation there so that a line of sight calculation can be performed and not just have missing data.\n(INSERT RASTERIZATION GRAPHIC)\nWe chose the “nearest neighbor” interpolation algorithm because it is extremely easy to implement. Initial tests showed that it doesn’t sacrifice accuracy either, having less than (? TOM MARGIN ?) difference than (? TOM INTERPOLATION ?).\nAttempting to make rotation a function mapping coordinates from the unrotated image onto to the rotated one also runs into trouble. Streaks will be unfilled because it isn’t guaranteed there is a one to one mapping of coordinates when there is rounding involved This is simply solved by doing an “anti rotation”. Looping over all the points of the output image, and choosing the closest one in the input.\nA Brief Intermission Get up, go get a drink of water or coffee, breathe a little. We’re through the hardest part!\nPlease enjoy this palette cleanser of a Shiba who is a shop-keeper. Finding The Longest Line of Sight Once we developed the optimal cache setup to guarantee that our calculations are no longer memory bound, the world became our oyster. A global total viewshed calculation seemed right on our doorstep.\nInitial runs showed that our algorithm ran at about ~120 seconds per angle with very little optimization, just straight-line Rust code. This timing means Everest takes 12 hours, but good news, it is single threaded so there’s plenty more to go.\nWith the high-level architecture complete we decided to name our algorithm, CacheTVS.\nCacheTVS has three different types of outputs:\nthe surface area heatmap, the point-by-point longest line of sight, the viewshed bitmaps The surface area heatmap is an estimate of the visible area from a point of view.\nThe point-by-point computation for the line of sight holds the angle and distance of the longest line of sight found.\nThe viewshed bitmaps are the boolean visibility computations out to the worst case line of sight for all 360 degrees.\nWe mainly only use the first two, as we calculated that storing the viewshed bitmap for Everest would be a few Terabytes worth of information, and it doesn’t actually get us anywhere. The world would be many Petabytes. We really only need a visualization of how much area each point can see, and of course the longest line of sight.\nIn total, we use exactly 8 times the amount of data of a single DEM which is entirely feasible and only around 200GB for the entire world.\nParallelizing CacheTVS As mentioned previously, all our initial tests were single threaded. Since the total viewshed calculation works on an angle by angle snapshot of the data, we can already parallelize this by the number of cores what we have, which for my machine is 8 cores. Because this workload is compute heavy, it doesn’t make sense to make use of SMT since threads will be fighting heavily for compute units.\nTo get the new time with 8-way parallelism, we just divide the amount of work, 360 angles, by the amount of cores and multiply by the number of seconds.\n$$ ((360 / 8) * 120\\space secs) / 60 \\space secs \\newline = ~1.5 \\space hrs $$\nWe’re under two hours!\nOptimizing Line of Sight Calculations With the easy parallelization out of the way, it is time to see if we can squeeze extra parallelism out of our processor. There are many ways in which a CPU is parallel, not just multi-threading. You also have instruction-level parallelism along with SIMD. Initially, lets focus on the first. Speaking of, what does our line of sight calculation currently look like?\nfn line_of_sight(pov_height: i16, refraction: f32, elevations: \u0026[i16]) -\u003e (f32, f32) { // (surface area, distance) let mut highest_angle = -f32::INF; let mut longest_distance = 0.0f32; let mut surface_area = 0.0f32; for (distance, elevation) in elevations.enumerate() { // calculate the curve and refraction adjustment let curve_and_refraction = ((distance.ipow(2) as f32) * (1 - refraction)) / EARTH_DIAMETER; let elevation_prime = (elevation as f32) + curve_and_refraction // calculate the \"angle\" (really a ratio, not arctan) let angle = (elevation_prime - (pov_height as f32)) / distance // as we determined in the beginning, if the angle is higher, // then the point along our elevation map is visible. // // Add its area to the surface area, and update the longest // distance we've seen, and set it as the new highest angle if angle \u003e highest_angle { longest_distance = distance as f32 highest_angle = angle // TAN_ONE_RADIAN comes from the original paper. I'm not // sure that it is correct, but it makes for a decent estimate surface_area += distance * TAN_ONE_RADIAN } } (surface_area, longest_distance) } ILP Go Brrrrr The main performance issues of this loop arise because each iteration depends on the last.\nCPUs work best when the next instruction doesn’t depend on the result of any other instruction before it. It uses instruction pipelining to issue multiple independent instructions. This is called Instruction Level Parallelism (ILP).\n(INSERT PIPELINING GRAPHIC)\nIn the case of the line of sight, the computation that is truly independent of any iteration is the angle computation. It is only based on distance and elevation, not any angle before or after.\nTo be able to unshackle it from the loop-cary dependency, we will need to trade off storing and re-loading it from memory to gain ILP. Thankfully this all still fits in L1 so the ILP benefits far outweigh the memory cost.\nWe can rewrite the loop as follows:\nfn line_of_sight(pov_height: i16, refraction: f32, elevations: \u0026[i16], angle_buf: \u0026mut [f32]) -\u003e (f32, f32) { // (surface area, distance) assert_eq(elevations.len(), angle_buf.len()) for (angle, (distance, elevation)) in zip(angle_buf.iter_mut(), elevations.enumerate()) { // calculate the curve and refraction adjustment let curve_and_refraction = ((distance.ipow(2) as f32) * (1 - refraction)) / EARTH_DIAMETER; let elevation_prime = (elevation as f32) + curve_and_refraction *angle = (elevation_prime - (pov_height as f32)) / distance } let mut highest_angle = -f32::INF; let mut longest_distance = 0.0f32; let mut surface_area = 0.0f32; for angle in angles { // as we determined in the beginning, if the angle is higher, // then the point along our elevation map is visible. // // Add its area to the surface area, and update the longest // distance we've seen, and set it as the new highest angle if angle \u003e highest_angle { longest_distance = distance as f32 highest_angle = angle // TAN_ONE_RADIAN comes from the original paper. I'm not // sure that it is correct, but it makes for a decent estimate surface_area += distance * TAN_ONE_RADIAN } } (surface_area, longest_distance) } We’ve now maximized the ILP of the angle calculation, but the longest line of sight calculation and surface area calculation still aren’t particularly parallel. Let’s fix that!\nPrefix Sums and Scans A prefix sum is a computation that takes a list of numbers and maps it to another list where each element becomes the cumulative some of all elements before it, hence its name. Here’s a sample implementation:\nlet nums = \u0026[1, 2, 3, 4, 5]; let mut prefix_sum = \u0026[0, 0, 0, 0, 0]; let mut prefix_acc = 0; for (prefix, num) in zip(prefix_sum.iter_mut(), nums) { prefix_acc += num; *prefix_sum = num } Abstractly, a prefix sum is part of a general family of algorithm called an “inclusive scan”. A scan is an even more general algorithm that takes a sequence, an associative binary operator, and applies the binary operator to an accumulated value and yields the new value. Rust actually has this in its standard library with .iter().scan()\nlet nums = \u0026[1, 2, 3, 4, 5]; // yields the same as above let prefix_sum = nums .iter() .scan(0, |acc, elem| { *acc += elem; Some(*acc) }) .collect() Why do we care about scans? Well, for the real numbers max also happens to be an associative binary operator.\nWhen we do our visibility calculations, we are comparing the current angle against the highest angle:\nif angle \u003e highest_angle { longest_distance = distance as f32 highest_angle = angle surface_area += distance * TAN_ONE_RADIAN } If we have a prefix maximum of all the previous angles, then we could independently calculate whether a particular point is visible by checking to see if angle \u003e prefix_max.\nFortunately for us, max also happens to be associative for the floating point values that we compute. Generally speaking, floating point values are not associative due to NaNs and signed zero. We never do any computation that could yield either result, meaning we are safe to use max associatively.\nScans also have two variants, inclusive and exclusive. Careful readers may have realized we aren’t comparing the highest angle to the prefix maximum which includes itself (like the above prefix sum). Instead, we are comparing the angle to the maximum of all previous angles (exclusive of itself). Thankfully switching from an inclusive to an exclusive scan fixes this.\nIf we allocate a second buffer and stuff the exclusive prefix maximum in there, our loop iterations calculating the total surface area become entirely independent of one another. Calculating the longest line of sight also falls out of our surface area calculation.\nHere’s the updated algorithm. I’ve broken it out into three methods as we now calculate the line of sight in three discrete steps:\nAngles Prefix maximum Visibility (surface area and longest line of sight) fn calculate_angles(pov_height: f32, refraction: f32, angle_buf: \u0026mut [f32], elevations: \u0026[i16]) { for (angle, (distance, elevation)) in zip(angle_buf.iter_mut(), elevations.enumerate()) { let curve_and_refraction = ((distance.ipow(2) as f32) * (1 - refraction)) / EARTH_DIAMETER; let elevation_prime = (elevation as f32) + curve_and_refraction *angle = (elevation_prime - (pov_height as f32)) / distance } } fn prefix_max(prefix_max_buf: \u0026mut [f32], angle_buf: \u0026[f32]) { let mut highest_seen = -f32::INF; for (prefix_max, (distance, angle)) in zip(prefix_max_buf.iter_mut(), angles.enumerate()) { *prefix_max = highest_seen; highest_seen = max(*prefix_max, highest_seen); } } fn visibility(angles: \u0026[f32], prefix_max: \u0026[f32]) -\u003e (f32, f32) { for ((distance, angle), prefix_max) in zip(angles.enumerate(), prefix_max) { if angle \u003e prefix_max { surface_area += distance * TAN_ONE_RADIAN longest_distance = distance } } (surface_area, longest_distance) } fn line_of_sight( pov_height: i16, refraction: f32, elevations: \u0026[i16], angle_buf: \u0026mut [f32], prefix_max_buf: \u0026mut [f32], ) -\u003e (f32, f32) { // (surface area, distance) assert_eq(elevations.len(), angle_buf.len()) calculate_angles(pov_height as f32, refraction, angle_buf, elevations); prefix_max(prefix_max_buf, angle_buf); visibility(angles, prefix_max) } Cache Pressure Ain’t Gonna Break My Stride Before parallelizing further, I noticed that our angle calculations redo the same curvature computation over and over. When you have potentially hundreds of millions of lines of sight to process, that’s quite a bit of extra computation. We haven’t hit an issue with cache pressure yet so let’s pre-compute the curve and refraction adjustment, and also pre-compute the distances between points. Tiles generally are of all the same scale, 100m, but we add it in for future use:\n// generate the curvature adjustments given the scale, refraction and worst case line of sight, `max_los`. fn generate_distances(max_los: usize, refraction: f32, scale: f32) -\u003e (Vec\u003cf32\u003e, Vec\u003cf32\u003e) { let adjusted_refraction = refraction - 1.0; (1..=max_los) .map(|step| { let distance = (step as f32) * scale; let adjustment = (distance * distance * adjusted_refraction) / EARTH_DIAMETER; (distance, adjustment) }) .unzip() } We now can run this once and keep it out of our angle calculation loop. Nice!\nClose enough, welcome back sector distances.\nSIMD, Baby We’ve almost squeezed every little bit of ILP out of our algorithm, so now is the time to talk about another type of parallelism. SIMD.\nSIMD stands for “Single Instruction Multiple Data”. SIMD widens registers by multiple times the width of data, say 8 f32s, and allows a single instruction to be issued to do computation on all elements.\nBecause the parallel nature of our computation, we are a good fit for rewriting the algorithm in SIMD. Instead of calculating a single angle at a time, we can calculate 8 at a time on my x86 machine - which has AVX2 - and as we’ll see later, up to 16 on AVX-512 machines.\nRust currently has an unstable feature called “portable SIMD” which lets us abstract over the hardware architecture, which will work well for our most basic computations.\nTrivially, we can use portable SIMD to widen both our angle and longest line of sight computations. Check it out:\n// requires #![feature(portable_simd)] use std::simd::prelude::SimdFloat as _; use std::simd::{LaneCount, Simd, SupportedLaneCount}; // fancy itertools macro that lets us zip multiple iterators into one big unnested tuple use itertools::izip; fn calculate_angles\u003cconst VECTOR_WIDTH: usize\u003e( pov_height: f32, angles_out: \u0026mut [f32], elevations, distances, adjustments) where LaneCount\u003cVECTOR_WIDTH\u003e : SupportedLaneCount { assert(elevations.len().is_multiple_of(VECTOR_WIDTH)); // turn a \u0026[f32] into a \u0026[[f32; VECTOR_WIDTH]]. The r.h.s of the assignment // is the portion that doesn't fit into VECTOR_WIDTH, but we can ignore it since // the length of the slice is asserted to be a multiple of VECTOR_WIDTH let (vector_angles, _) = angles_out.as_chunks_mut::\u003c{ VECTOR_WIDTH }\u003e(); let (vector_elevations, _) = elevations.as_chunks::\u003c{ VECTOR_WIDTH }\u003e(); let (vector_adjustments, _) = adjustments.as_chunks::\u003c{ VECTOR_WIDTH }\u003e(); let (vector_distances, _) = distances.as_chunks::\u003c{ VECTOR_WIDTH }\u003e(); for (angle_out, \u0026elevation, \u0026distance, \u0026adjustment) in izip!( vector_angles.iter_mut(), vector_elevations.iter(), vector_distances.iter(), vector_adjustments.iter() ) { let elevation_f32: Simd\u003cf32, { VECTOR_WIDTH }\u003e = Simd::from(elevation).cast(); let elevation_prime = elevation_f32 + Simd::from_array(adjustment); let res = (elevation_prime - Simd::splat(pov_height)) / Simd::from_array(distance); res.copy_to_slice(angle_out); } } fn visibility\u003cconst VECTOR_WIDTH: usize\u003e(angles: \u0026[f32], prefix_max: \u0026[f32], distances: \u0026[f32]) -\u003e (f32, f32) where LaneCount\u003cVECTOR_WIDTH\u003e : SupportedLaneCount { assert(angles.len().is_multiple_of(VECTOR_WIDTH)); let (vector_angles, _) = angles.as_chunks::\u003c{ VECTOR_WIDTH }\u003e(); let (vector_prefix, _) = prefix_max.as_chunks::\u003c{ VECTOR_WIDTH }\u003e(); let (vector_distances, _) = distances.as_chunks::\u003c{ VECTOR_WIDTH }\u003e(); let (simd_area, simd_longest_distance) = izip(angles, distances, prefix_max) .fold((Simd::splat(0.0f32), Simd::splat(0.0f32)), |((acc_area, acc_distances), (angle, distance, prefix_max)) { let mask = angle.simd_gt(prefix_max); // if we don't have _any_ elements, then why carry out the rest of the computation? if !mask.any() { return (acc_area, acc_distances); } let selected_distances = mask.select(distance, Simd::splat(0.0f32)); let surface_area = selected_distances * Simd::splat(TAN_ONE_RADIAN); (acc_area + surface_area, acc_distances.simd_max(selected_distances)) }| } (simd_area.reduce_sum(), simd_longest_distance.reduce_max()) } SIMD is a different way of thinking because as you may notice, there are no conditionals. Instead, each element is compared pairwise with each other to create a “mask”. Then, you use that mask to “select” which elements you want to use for true (the distances) and which to use for false (zero).\nRust has some interesting codegen for the !mask.any() that I haven’t fully grokked so will need to write a separate post about, but suffice it to say that it shaved 10% off of our time. If no points are visible, there’s no reason to do any other calculation so this makes sense.\nx86 and IEEE754 Rust strives to be a safe language, so all float computations are done without the fastmath flags. Enabling the fastmath flags in Rust is annoying, and also not recommended for various other reasons. One reason why you might want to turn on fastmath flags is that at least on x86, some instructions such as comparisons and floating point maximums end up generating a lot of extra instructions to comply with IEEE floating point standards because guess what: Intel’s instructions don’t.\nFor this project, we actually don’t care a ton about the IEEE standard for comparison or maximum as we aren’t generating any NaNs or signed zero. For x86 we implement max with the _mm_max_ps intrinsic and implement greater than with the _mm_gt_ps. No extra instructions.\nThis gets more important in our next section because we are going to make use of the max instruction quite a bit, and we need to make sure a minimal number of instructions are generated. It’s all to help us sop avoiding the SIMD elephant in the room: the prefix maximum calculation.\nParallel Scans With SIMD Calculating the prefix maximum with multiple threads would induce a huge amount of overhead for a small amount of work, so instead we want to parallelize our prefix maximum via SIMD. The level of parallelism we get out of the algorithm will be from clearing up the instruction pipeliner and keep the carried dependencies minimal.\nBecause max is associative, we can calculate the prefix maximum for all the angles that fit within a single SIMD register keeping all calculations independent of one another and make ILP go brrr. Then we loop back over the data to propagate the maximum of each through the data. A common pattern you may be picking up on.\nFor example, lets say we have the following angles in two 4-wide registers.\n[1, -1, 2, -2], [3, -3, 4, -4] We can calculate the prefix max of the first register by shifting in an identity element - in our case -f32::INF - and applying our binary operator max. Then we take result of that and shift in two identity elements to finish calculating the prefix max in-place:\nmax([ 1, -1, 2, -2], [-INF, 1, -1, 2]) = [1, max(-1, 1), max(2, -1), max(-2, -1)] Then reuse that for the next in-place prefix max:\nmax([ 1, max(-1, 1), max(2, -1), max(-2, -1)], [-INF, -INF, 1, max(1, -1)]) = [1, max(-1, 1), max(max(2, -1), 1), max(max(-2, -1), max(1, -1))] = [1, 1, 2, 2] We do the same for the second register, independently:\nmax([ 3, -3, 4, -4], [-INF, 3, -3, 4]) = [3, max(-3, 3), max(4, -3), max(-4, 4)] Which needs to be reused for the next in-place prefix max:\nmax([ 3, max(-3, 3), max(4, -3), max(-4, 4)], [-INF, -INF, 3, max(1, -1)] = [3, 3, 4, 4] Now, we can take the maximum of the first register, which is always the last element, and splat it across a whole SIMD register, then call max to complete the process:\nmax([3, 3, 4, 4], [2, 2, 2, 2]) = [3, 3, 4, 4] No change here. But as you can see, associativity is what lets us do this prefix maximum calculation register and lets us only do \\(log_2(4) = 2\\) calls to max. When we use 8 or 16 wide registers it is still \\(log_2\\), so only a modest increase of one or two extra shifts. It also saves us from having to compute something like max(max(max(1, -1), 2), -2).\nIf you are interested in the nitty-gritty, you can take a look at the implementation or also take a look at this website or this paper that were great guides and help in implementing a prefix maximum.\nReduction Now that we are able to calculate the longest line of sight for a given point, we need to do this for every point on the map. Since we also only go in a single direction, we need to run that for every angle.\nAs cores finish up doing their single angle heatmap and line of sight calculation, we simply accumulate their results into a single “final map” which is the result of the accumulated data for all 360 degrees.\nFinal Results After implementing all of the above optimizations and absolutely squeezing the rock as hard as I could, water did in fact come out. We took the computation from 120 seconds an angle, down to\nDRUM ROLL PLEASE\n75 seconds per angle.\nAstounding. This brought us down to 57 minutes for all of Everest on my 8 core machine. Every little bit of optimization and tuning brought us here, and it was because of the hard work we put in that we were getting very close to something usable for a world run. There was one last thing that was holding me back: AVX-512.\nVery, very recently, AMD released its Turin line of processor which has full AVX-512F support. Which means rather than having AVX-512 be two AVX2 calculations in a trench-coat, it is a first-class citizen. Renting a top of the line AMD Turin and our use of const generics and portable SIMD implementation let us seamlessly turn on support for a 16-wide angle calculation, prefix max, and longest line of sight calculation. Enabling it halved the time per angle, cutting down the calculation to an average of 35 seconds per angle.\nUsing the Turins also unlocked a huge number of more cores. I found that 48 cores was the sweet spot for our algorithm. Now instead of taking an hour, with 48 cores and AVX512, we were taking 4 minutes for all of Everest. ALL OF EVEREST. This is a 160x speedup over the initial GPU algorithm.\nIt should be noted that there are a good number of cores that get wasted when running with a core count that doesn’t evenly divide 360. Cores idling waiting for the next angle which doesn’t come but we leave this as future work.\nA Full World Run Now that we were confident that we had the quickest algorithm we could think up, it was time to run the longest line of sight algorithm for every tile in the whole world. Tom calculated the worst case line of sight that covered the globe. Chunking the world up as such ended with roughly 2500 tiles ranging from 50 kilometers across to a whopping 800km across.\nSince our algorithm is \\(O(n^3)\\) where \\(n\\) is the worst case line of sight, small tiles will run in much quicker than 4 minutes, while larger tiles will take much longer than 4 minutes. About 50% of the tiles are under 450km, whereas 50% of the total area of all tiles comes in at 1900 tiles and under 650km. We still had a tall task.\nTo process all the tiles, we took a stab at a Tom-and-Ryan version of MapReduce cluster of 5 AMD Turin machines which we called Atlas, which you can read about here.\nAll in all, the full world run took 18 hours and cost us a few hundred dollars which is much less than the few hundred thousand that Tom initially estimated.\nThe Final Product Looking for the longest line of sight? Go check it out at https://alltheviews.world and see our curated list of the top ten longest lines of sight. You won’t believe number 3!\nDon’t forget to go play with the interactive map athttps://map.alltheviews.world to find the longest line of sight for any location on earth, or even the longest line of sight for your country or state!\nIf you want to take a look at Atlas, you can so here. If you would like to take a look at all the code this blog post is about, here is the link for the repo of our total viewshed algorithm, CacheTVS.\nAcknowledgements I’d like to acknowledge Tom for being the rock for which all this research was able to take place. My family and friends for listening to my insane ramblings. They really didn’t know much that was going on until it became visual.\nA big thanks Matt Flatt for teaching my CS4400 class in college that gave me the language and tools to approach these performance issues.\nI’d also like to thank my dog for spending many of my late nights curled up on the couch with me.\nSo long, and thanks for all the fish!\n","wordCount":"5982","inLanguage":"en","datePublished":"2026-02-01T20:10:00-07:00","dateModified":"2026-02-01T20:10:00-07:00","author":[{"@type":"Person","name":"Ryan Berger"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://ryan.berge.rs/posts/total-viewshed-algorithm/"},"publisher":{"@type":"Organization","name":"Ryan Berger's Page","logo":{"@type":"ImageObject","url":"https://ryan.berge.rs/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://ryan.berge.rs/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://ryan.berge.rs/blog/ title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ryan.berge.rs/>Home</a>&nbsp;»&nbsp;<a href=https://ryan.berge.rs/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">A Total Viewshed Algorithm to Find the Longest Line of Sight
<span class=entry-hint title=Draft><svg height="35" viewBox="0 -960 960 960" fill="currentColor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h1><div class=post-meta><span title='2026-02-01 20:10:00 -0700 -0700'>February 1, 2026</span>&nbsp;·&nbsp;29 min&nbsp;·&nbsp;Ryan Berger</div></header><div class=post-content><blockquote><p><em>Welcome all readers from the <a href=../lines-of-sight>non-technical lines of sight post</a></em></p></blockquote><p>The past 6 months of almost every moment of my free time has been spent developing an algorithm with my friend
Tom Buckley-Houston to exhaustively prove that we&rsquo;ve found the longest line of sight in the world. We both felt it was very
doable algorithmically, but current options looked extremely computationally intensive.</p><p>Since the inception of the project, through hard work and collaboration we have been able to speed up the calculations
by hundreds of times, and make it entirely feasible on top-of-the-line CPUs such as the AMD Turin.
Please enjoy the deep dive, and make sure to check out <a href=https://tombh.co.uk/longest-line-of-sight>Tom&rsquo;s sister blogpost</a>
and <a href=https://alltheviews.world>https://alltheviews.world</a> for the final product!</p><h2 id=the-total-viewshed-algorithm>The Total Viewshed Algorithm<a hidden class=anchor aria-hidden=true href=#the-total-viewshed-algorithm>#</a></h2><p>A <a href=https://en.wikipedia.org/wiki/Viewshed>viewshed</a> is all the area visible from a particular location on the map:</p><figure class=align-center><img loading=lazy src=/lines/cardiff_viewshed.webp#center></figure><p>It also happens to hold the longest line of sight, since it is the furthest
visible point from the observer.</p><p>Traditional viewshed algorithms take Digital Elevation Mappings (DEMs) and calculate the angles pair-wise for all points
and then determine whether there are obstructions. This approach works well for a single viewshed, however, scaling to
more than one runs head-first into cache issues.</p><p>You could imagine if you naively apply this pair-wise computation you end up re-fetching and re-calculating quite a lot.
Tools like ArcGIS do single viewshed calculations on the order of minutes, which works just fine for a single viewshed
but makes every point on the planet algorithmically infeasible, so a new solution was needed. We needed a &ldquo;total viewshed&rdquo; algorithm,
not just a single viewshed.</p><p>Enter, the total viewshed algorithm.</p><h3 id=line-of-sight-visibility>Line of Sight Visibility<a hidden class=anchor aria-hidden=true href=#line-of-sight-visibility>#</a></h3><p>At the foundation of the total (or single) viewshed algorithm lies the humble line of sight visibility calculation.
The line of sight visibility is the measure of visibility for some slice of the viewshed, say one
degree, which accumulated makes up a full viewshed.</p><p>Line of sight visibility calculations are entirely boolean (is the point visible to the observer or not) and are entirely
two-dimensional. To make this three-dimensional slice of space two-dimensional, we use an azimuthal projection to
project our observer into a two-dimensional space.</p><p>(INSERT GRAPHIC OF OBSERVER)</p><p>The elevations &ldquo;in front of&rdquo; the observer on the y-axis, distance on the x. The line of sight may lie between
two elevations so an interpolated value is chosen and a &ldquo;band&rdquo; of sight is also chosen, meaning the observer sees
exactly one point at a time.</p><p>(INSERT ANGLE GRAPHIC)</p><p>The angle of elevation between two points must also take into account the curvature of the earth,
along with the refraction of light. The equation for the adjusted elevation is given by the following equation [<a href=https://pro.arcgis.com/en/pro-app/3.4/tool-reference/3d-analyst/how-line-of-sight-works.htm>1</a>]:</p><p>$$
E^\prime = E + (D^2(R - 1) / d_{earth}); \newline
$$</p><p>Where \(E^\prime\) is the adjusted elevation, \(D\) is the distance to the point, \(R\) is a refraction coefficient
which has been calculated to be \(\approx.13\), and \(d_{earth}\) is the diameter of the earth in kilometers.</p><p>The angle of elevation, \(\theta\), between a point along the line of sight forms a right triangle. Since adjusted elevation is on
the opposite side of the triangle, while the distance to the point is the adjacent side, \(tan\) will be our friend:
$$
tan(\theta) = (E^\prime - h_{pov}) / D \newline
\theta = tan^{-1}((E^\prime - h_{pov}) / D)
$$</p><p>Where \(h_{pov}\) is the height of the observer.</p><blockquote><p><em><strong>Math Nerd (arc)Tangent</strong>:</em></p><p>For computational purposes we won&rsquo;t actually carry out \(tan^{-1}\). We can get away with this because
it is continuous and monotonically increasing on \((-\infty, \infty)\). This means
\( tan^{-1}(x_1) > tan^{-1}(x_2) \iff x_1 > x_2 \) so the extra computation doesn&rsquo;t get us anywhere</p></blockquote><p>Once the elevations are laid out, we can determine visibility for each point along the line of sight.
A point is visible to the observer if the angle of elevation between the observer and the point is greater than all
the previous angles of elevation of closer points. The angle between the point of view and itself \(-\infty\) since there is
&ldquo;no angle&rdquo; and we want all angles to be greater than it.</p><p>(INSERT PREFIX MAX GRAPHIC)</p><p>Rotating this line of sight calculation around for a point for all 360 degrees will give you 360 different bitmaps
of which points are visible, which you can then use to construct a viewshed. Tada!</p><h3 id=total-viewsheds>Total Viewsheds<a hidden class=anchor aria-hidden=true href=#total-viewsheds>#</a></h3><p>Now that we have line of sight visibility down, we can move on to the meat, the total viewshed.</p><p>There isn&rsquo;t a ton of literature existing for calculating total viewsheds for large maps. However, there are a few
prolific authors in the total viewshed space who have published many papers namely Tabik et al. My friend Tom
read their initial <a href=https://ieeexplore.ieee.org/document/6837455>total viewshed paper</a> back in 2020 while researching
how to find the longest line of sight, which had been a dream of his.</p><p>In the paper, they lay out a solution that attempts to parallelize a single viewshed calculation to calculate a total viewshed.
Their approach makes use of Linear Algebra to find the closest points to a normal vector (that they call the sector)
so they can determine which points to sample along the line of sight visibility calculation. In the paper they call
this &ldquo;sector ordering&rdquo;.</p><p>(INSERT GRAPHIC ABOUT SECTOR DISTANCES)</p><p>Sector distances are not necessarily uniform from point to point (effectively making a potential zigzag) along the line
of sight so they must also be kept track of.</p><p>(INSERT GRAPHIC ABOUT ZIGZAG)</p><p>They construct the line of sight projection using a linked list container like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> node {
</span></span><span style=display:flex><span>    node<span style=color:#f92672>*</span> prev; <span style=color:#75715e>// previous elevation in line of sight
</span></span></span><span style=display:flex><span>    node<span style=color:#f92672>*</span> next; <span style=color:#75715e>// next elevation in line of sight
</span></span></span><span style=display:flex><span>    int16<span style=color:#f92672>*</span> data; <span style=color:#75715e>// elevation data
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> distance; <span style=color:#75715e>// distance from pov
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The linked list elevation data isn&rsquo;t a copy of the elevation data, it is a pointer to it.
This then gets shipped off to a GPU for visibility calculation. The linked list gets reconstructed for every line of
sight for every point and angle duplicating a ton of work.</p><p>Very quickly Tom found that the linked list is Not A Good Idea™. In fact, the maximum line of sight is always
going to have some upper bound, so we can pre-allocate an array of that size. Rather than pointers, Tom calculated
position-independent offsets into the DEM, which he called &ldquo;deltas&rdquo;.</p><p>Tom also was able to make a parallel array for the sector distance. This way you add your delta to get the elevation,
you use the distance from the sector distance array, and then you are able to calculate the angle to the point along the
line of sight.</p><p>Those offsets stay the same for every angle, so Tom only ever had to calculate them once rather for each point (? TOM ?)
like the paper.</p><p>(INSERT DELTA GRAPHIC)</p><p>With deltas, you take your point of view&rsquo;s index, add the delta, and it gives you the index into the DEM of your
next point corresponding to your projected line of sight for that angle. Do this for every point for every angle and
you have a total viewshed. No linked list or pointers involved.</p><p>Tom left his improvements on the back burner for a few years until July 2025 when he started porting it to Rust.</p><h3 id=crazy-initial-estimates>Crazy Initial Estimates<a hidden class=anchor aria-hidden=true href=#crazy-initial-estimates>#</a></h3><p>Tom&rsquo;s initial runs showed that running all of Everest took about 12 hours at a measly 600km worst case
line of sight. Tom theorized that the actual worst case line of sight was 800km, which meant that
with an algorithm that has to check a DEM which has \(n \times n\) elevations, and you check a total of
\(n\) elevations along your line of sight for 360 angles, you are looking at potentially taking almost 2.4x longer
with a 1.3x longer worst case line of sight.</p><p>Tom&rsquo;s initial estimates were that this would cost us potentially hundreds of thousands of dollars and many months
of spot instance compute (meaning it could be shut down at any time). This was not feasible for either of our time
or money budgets, and I was certain that we could do better and calculate the whole world.</p><h2 id=down-the-rabbithole>Down the Rabbithole<a hidden class=anchor aria-hidden=true href=#down-the-rabbithole>#</a></h2><p>After rubbing some braincells together on the problem and re-implementing the algorithm myself, I noticed a complete lack
of cache locality. Tom&rsquo;s total viewshed algorithms may not have to recompute the &ldquo;deltas&rdquo; for each point, but it
is effectively a single viewshed algorithm applied for every point. Not exactly good for having to compute every viewshed.</p><p>The points are not processed in any particular order, meaning that while you are working from
left to right within the DEM, you are likely accessing completely different elevations.</p><p>(INSERT GRAPHIC OF DIAGONAL 45 DEGREE)</p><p>This effectively benchmarks your processors prefetcher with the number of cache misses you&rsquo;ll incur, not the line of
sight calculation.</p><p>How bad are these cache misses? Well, the elevation data we have is at a resolution of 100m. For our lower-than-needed
upper bound of 600km for Mount Everest&rsquo;s we are talking 36 million elevations. Those elevations are stored as i16s
totaling ~72MBs. Much bigger than what L3 can fit.</p><h3 id=sorting-by-lines-of-sight>Sorting By Lines of Sight<a hidden class=anchor aria-hidden=true href=#sorting-by-lines-of-sight>#</a></h3><p>My mind first went to &ldquo;sorting by lines of sight&rdquo;. Deltas take a single point and get us to the next point, but don&rsquo;t
care about what order your process points in. Since the next point is now in cache, it would be nice to reuse the data
for the next line of sight calculation.</p><p>However, this falls flat on its face very quickly for a very simple reason: a line of sight is not contiguous in terms
of memory. By accessing non-contiguous memory you may be loading <em>some</em> of the data into cache, but most of it is
not being used in the line of sight calculation.</p><p>(INSERT CACHE WASTE)</p><p>In fact, in the worst case since elevation data is stored as an <code>i16</code> you are wasting 96% of a 64 byte cache line. OUCH.</p><p>With that much data being wasted, I set out to try guarantee all data accesses for all lines of sight were contiguous,
and wouldn&rsquo;t you have it, all the squinting and rotating my head paid off.</p><h3 id=spinning-in-circles>Spinning In Circles<a hidden class=anchor aria-hidden=true href=#spinning-in-circles>#</a></h3><p>After staring at deltas and their corresponding distances for much too long, the deltas for 45 degrees popped out as me
as particularly interesting. Not only were lines of sight much faster to calculate for 45 degrees, but visualizing the
deltas showed that they create perfectly diagonal lines from the point of view and going across the DEM.
The distances were also entirely uniform between points.</p><p>(INSERT DIAGONAL LINES)</p><p>Since these lines are perfectly straight, why couldn&rsquo;t I make them entirely contiguous in memory and process the lines
of sight from left to right instead of corner to corner?</p><p>(INSERT ROTATED SQUARE)</p><p>This looked absolutely too good to be true! Surely rotating the map only works for some points but not all. And maybe
it gets strange at angles that aren&rsquo;t divisible by 45 and the whole idea is dead in the water? Would the distances
be able to stay continuous? After wondering if this was doable or missing points, Tom and I sat down and generated this image:</p><p>(INSERT ROTATED LOGO)</p><p>Tom had already noticed that the original authors were only calculating lines of sight internally to the viewshed.
When it came to calculating the full line of sight for every point they stopped short, mentioning it as a limitation
of the algorithm.</p><p>However, if you have 3x the data padding the tile, all lines of sight will be able to be calculated for lines
of sight for all angles. While messing with rotations, we realized that only 2 times the data is required for computing
the line of sight per angle. Instead of rotating the enitre DEM, we only need to rotate a rectangular portion,
which we nick-named the &ldquo;chocolate bar&rdquo;</p><p>(INSERT CHOCOLATE BAR)</p><p>The square tiles were now outliving their usefulness. When rotating the rectangle, it sometimes &ldquo;juts&rdquo; outside
the DEM, meaning we don&rsquo;t have the data for it. We nick-named these &ldquo;dolphins&rdquo; because they create little triangles
when overlaid with the DEM.</p><p>(INSERT DOLPHINS)</p><p>Dolphins occur because squares don&rsquo;t have infinite rotational symmetry so stuffing a rotated tile back into a square causes
it to be cut off. To fix this, we can just use circular tiles. The total viewshed is still padded with 3x the data,
except it is now 3 times the diameter of the worst-case longest line of sight.</p><p>The deltas and sector distances are dead! Viva la Rotación!</p><h3 id=the-stars-mostly-align>The Stars (Mostly) Align<a hidden class=anchor aria-hidden=true href=#the-stars-mostly-align>#</a></h3><p>Now that we rotate the map, we completely front-load all all our cache misses and perfectly align our data for our
one-direction line of sight calculations. This all incurs only a one-second penalty for even the biggest DEMs. A huge win.</p><p>Cutting down the amount of data ends up meaning we can fit multiple widths worth of the DEM into L1 for calculation.
Another HUGE win.</p><p>There is one downside that bears mentioning: when calculating the rotated coordinates for an elevation it may not fall
between a single elevation evenly. You have to choose interpolate some elevation there so that a line of sight
calculation can be performed and not just have missing data.</p><p>(INSERT RASTERIZATION GRAPHIC)</p><p>We chose the &ldquo;nearest neighbor&rdquo; interpolation algorithm because it is extremely easy to implement.
Initial tests showed that it doesn&rsquo;t sacrifice accuracy either, having less than (? TOM MARGIN ?) difference than (? TOM INTERPOLATION ?).</p><p>Attempting to make rotation a function mapping coordinates from the unrotated image onto to the rotated one also runs
into trouble. Streaks will be unfilled because it isn&rsquo;t guaranteed there is a one to one mapping of coordinates when
there is rounding involved This is simply solved by doing an &ldquo;anti rotation&rdquo;.
Looping over all the points of the output image, and choosing the closest one in the input.</p><h2 id=a-brief-intermission>A Brief Intermission<a hidden class=anchor aria-hidden=true href=#a-brief-intermission>#</a></h2><p>Get up, go get a drink of water or coffee, breathe a little. We&rsquo;re through the hardest part!</p><p>Please enjoy this palette cleanser of a Shiba who is a shop-keeper.<div style=display:flex;justify-content:center><iframe width=560 height=315 src=https://www.youtube.com/embed/E6CcUj2mDbI title="YouTube video player" frameborder=0 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy=strict-origin-when-cross-origin allowfullscreen></iframe></div></p><h2 id=finding-the-longest-line-of-sight>Finding The Longest Line of Sight<a hidden class=anchor aria-hidden=true href=#finding-the-longest-line-of-sight>#</a></h2><p>Once we developed the optimal cache setup to guarantee that our calculations are no longer
memory bound, the world became our oyster. A global total viewshed calculation seemed right on our doorstep.</p><p>Initial runs showed that our algorithm ran at about ~120 seconds per angle with very little optimization, just straight-line
Rust code. This timing means Everest takes 12 hours, but good news, it is single threaded so there&rsquo;s plenty more to go.</p><p>With the high-level architecture complete we decided to name our algorithm, <em><strong>CacheTVS</strong></em>.</p><p>CacheTVS has three different types of outputs:</p><ul><li>the surface area heatmap,</li><li>the point-by-point longest line of sight,</li><li>the viewshed bitmaps</li></ul><p>The surface area heatmap is an estimate of the visible area from a point of view.</p><p>The point-by-point computation for the line of sight holds the angle and distance of the longest line of sight found.</p><p>The viewshed bitmaps are the boolean visibility computations out to the worst case line of sight for all 360 degrees.</p><p>We mainly only use the first two, as we calculated that storing the viewshed bitmap for Everest would be a few Terabytes
worth of information, and it doesn&rsquo;t actually get us anywhere. The world would be many Petabytes. We really only need a
visualization of how much area each point can see, and of course the longest line of sight.</p><p>In total, we use exactly 8 times the amount of data of a single DEM which is entirely feasible and only around
200GB for the entire world.</p><h3 id=parallelizing-cachetvs>Parallelizing CacheTVS<a hidden class=anchor aria-hidden=true href=#parallelizing-cachetvs>#</a></h3><p>As mentioned previously, all our initial tests were single threaded. Since the total viewshed calculation works
on an angle by angle snapshot of the data, we can already parallelize this by the number of cores what we have,
which for my machine is 8 cores. Because this workload is compute heavy, it doesn&rsquo;t make sense to make use of SMT
since threads will be fighting heavily for compute units.</p><p>To get the new time with 8-way parallelism, we just divide the amount of work, 360 angles, by the amount of cores
and multiply by the number of seconds.</p><p>$$
((360 / 8) * 120\space secs) / 60 \space secs \newline
= ~1.5 \space hrs
$$</p><p>We&rsquo;re under two hours!</p><h3 id=optimizing-line-of-sight-calculations>Optimizing Line of Sight Calculations<a hidden class=anchor aria-hidden=true href=#optimizing-line-of-sight-calculations>#</a></h3><p>With the easy parallelization out of the way, it is time to see if we can squeeze extra parallelism out of our processor.
There are many ways in which a CPU is parallel, not just multi-threading. You also have instruction-level
parallelism along with SIMD. Initially, lets focus on the first. Speaking of, what does our line of sight calculation currently look like?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>line_of_sight</span>(pov_height: <span style=color:#66d9ef>i16</span>, refraction: <span style=color:#66d9ef>f32</span>, elevations: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>i16</span>]) -&gt; (<span style=color:#66d9ef>f32</span>, <span style=color:#66d9ef>f32</span>) { <span style=color:#75715e>// (surface area, distance)
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> highest_angle <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#66d9ef>f32</span>::<span style=color:#66d9ef>INF</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> longest_distance <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span><span style=color:#66d9ef>f32</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> surface_area <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span><span style=color:#66d9ef>f32</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (distance, elevation) <span style=color:#66d9ef>in</span> elevations.enumerate() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// calculate the curve and refraction adjustment
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> curve_and_refraction <span style=color:#f92672>=</span> ((distance.ipow(<span style=color:#ae81ff>2</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>) <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> refraction)) <span style=color:#f92672>/</span> <span style=color:#66d9ef>EARTH_DIAMETER</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> elevation_prime <span style=color:#f92672>=</span> (elevation <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>) <span style=color:#f92672>+</span> curve_and_refraction
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// calculate the &#34;angle&#34; (really a ratio, not arctan)
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> angle <span style=color:#f92672>=</span> (elevation_prime <span style=color:#f92672>-</span> (pov_height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>)) <span style=color:#f92672>/</span> distance
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// as we determined in the beginning, if the angle is higher,
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// then the point along our elevation map is visible.
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>//
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// Add its area to the surface area, and update the longest
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// distance we&#39;ve seen, and set it as the new highest angle
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> angle <span style=color:#f92672>&gt;</span> highest_angle {
</span></span><span style=display:flex><span>            longest_distance <span style=color:#f92672>=</span> distance <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>
</span></span><span style=display:flex><span>            highest_angle <span style=color:#f92672>=</span> angle
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// TAN_ONE_RADIAN comes from the original paper. I&#39;m not
</span></span></span><span style=display:flex><span>            <span style=color:#75715e>// sure that it is correct, but it makes for a decent estimate
</span></span></span><span style=display:flex><span>            surface_area <span style=color:#f92672>+=</span> distance <span style=color:#f92672>*</span> <span style=color:#66d9ef>TAN_ONE_RADIAN</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    (surface_area, longest_distance)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=ilp-go-brrrrr>ILP Go Brrrrr<a hidden class=anchor aria-hidden=true href=#ilp-go-brrrrr>#</a></h3><p>The main performance issues of this loop arise because each iteration depends on the last.</p><p>CPUs work best when the next instruction doesn&rsquo;t depend on the result of any other instruction before it. It uses
<em>instruction pipelining</em> to issue multiple independent instructions. This is called Instruction Level Parallelism (ILP).</p><p>(INSERT PIPELINING GRAPHIC)</p><p>In the case of the line of sight, the computation that is truly independent of any iteration is
the angle computation. It is only based on distance and elevation, not any angle before or after.</p><p>To be able to unshackle it from the loop-cary dependency, we will need to trade off storing and re-loading it from
memory to gain ILP. Thankfully this all still fits in L1 so the ILP benefits far outweigh the memory cost.</p><p>We can rewrite the loop as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>line_of_sight</span>(pov_height: <span style=color:#66d9ef>i16</span>, refraction: <span style=color:#66d9ef>f32</span>, elevations: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>i16</span>], angle_buf: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> [<span style=color:#66d9ef>f32</span>]) -&gt; (<span style=color:#66d9ef>f32</span>, <span style=color:#66d9ef>f32</span>) { <span style=color:#75715e>// (surface area, distance)
</span></span></span><span style=display:flex><span>    assert_eq(elevations.len(), angle_buf.len())
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (angle, (distance, elevation)) <span style=color:#66d9ef>in</span> zip(angle_buf.iter_mut(), elevations.enumerate()) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// calculate the curve and refraction adjustment
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> curve_and_refraction <span style=color:#f92672>=</span> ((distance.ipow(<span style=color:#ae81ff>2</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>) <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> refraction)) <span style=color:#f92672>/</span> <span style=color:#66d9ef>EARTH_DIAMETER</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> elevation_prime <span style=color:#f92672>=</span> (elevation <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>) <span style=color:#f92672>+</span> curve_and_refraction
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>angle <span style=color:#f92672>=</span> (elevation_prime <span style=color:#f92672>-</span> (pov_height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>)) <span style=color:#f92672>/</span> distance
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> highest_angle <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#66d9ef>f32</span>::<span style=color:#66d9ef>INF</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> longest_distance <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span><span style=color:#66d9ef>f32</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> surface_area <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span><span style=color:#66d9ef>f32</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> angle <span style=color:#66d9ef>in</span> angles {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// as we determined in the beginning, if the angle is higher,
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// then the point along our elevation map is visible.
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>//
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// Add its area to the surface area, and update the longest
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// distance we&#39;ve seen, and set it as the new highest angle
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> angle <span style=color:#f92672>&gt;</span> highest_angle {
</span></span><span style=display:flex><span>            longest_distance <span style=color:#f92672>=</span> distance <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>
</span></span><span style=display:flex><span>            highest_angle <span style=color:#f92672>=</span> angle
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// TAN_ONE_RADIAN comes from the original paper. I&#39;m not
</span></span></span><span style=display:flex><span>            <span style=color:#75715e>// sure that it is correct, but it makes for a decent estimate
</span></span></span><span style=display:flex><span>            surface_area <span style=color:#f92672>+=</span> distance <span style=color:#f92672>*</span> <span style=color:#66d9ef>TAN_ONE_RADIAN</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    (surface_area, longest_distance)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We&rsquo;ve now maximized the ILP of the angle calculation, but the longest line of sight calculation and
surface area calculation still aren&rsquo;t particularly parallel. Let&rsquo;s fix that!</p><h3 id=prefix-sums-and-scans>Prefix Sums and Scans<a hidden class=anchor aria-hidden=true href=#prefix-sums-and-scans>#</a></h3><p>A prefix sum is a computation that takes a list of numbers and maps it to another list
where each element becomes the cumulative some of all elements before it, hence its name. Here&rsquo;s a sample
implementation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> nums <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> prefix_sum <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> prefix_acc <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (prefix, num) <span style=color:#66d9ef>in</span> zip(prefix_sum.iter_mut(), nums) {
</span></span><span style=display:flex><span>    prefix_acc <span style=color:#f92672>+=</span> num;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>prefix_sum <span style=color:#f92672>=</span> num
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Abstractly, a prefix sum is part of a general family of algorithm called an &ldquo;inclusive scan&rdquo;. A scan is an even more general
algorithm that takes a sequence, an associative binary operator, and applies the binary operator to an accumulated value
and yields the new value. Rust actually has this in its standard library with <code>.iter().scan()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> nums <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// yields the same as above
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> prefix_sum <span style=color:#f92672>=</span> nums
</span></span><span style=display:flex><span>    .iter()
</span></span><span style=display:flex><span>    .scan(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>|</span>acc, elem<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>acc <span style=color:#f92672>+=</span> elem;
</span></span><span style=display:flex><span>        Some(<span style=color:#f92672>*</span>acc)
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    .collect()
</span></span></code></pre></div><p>Why do we care about scans? Well, for the real numbers <code>max</code> also happens to be an associative binary operator.</p><p>When we do our visibility calculations, we are comparing the current angle against the <em>highest</em> angle:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>if</span> angle <span style=color:#f92672>&gt;</span> highest_angle {
</span></span><span style=display:flex><span>    longest_distance <span style=color:#f92672>=</span> distance <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>
</span></span><span style=display:flex><span>    highest_angle <span style=color:#f92672>=</span> angle
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    surface_area <span style=color:#f92672>+=</span> distance <span style=color:#f92672>*</span> <span style=color:#66d9ef>TAN_ONE_RADIAN</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If we have a <em>prefix maximum</em> of all the previous angles, then we could independently calculate
whether a particular point is visible by checking to see if <code>angle > prefix_max</code>.</p><p>Fortunately for us, <code>max</code> also happens to be associative for the floating point values that we compute. Generally speaking,
floating point values are not associative due to <code>NaN</code>s and signed zero. We never do any computation that
could yield either result, meaning we are safe to use <code>max</code> associatively.</p><p>Scans also have two variants, inclusive and exclusive. Careful readers may have realized we aren&rsquo;t comparing the
highest angle to the prefix maximum which includes itself (like the above prefix sum). Instead, we are comparing
the angle to the maximum of all <em>previous</em> angles (exclusive of itself). Thankfully switching from an inclusive to an
exclusive scan fixes this.</p><p>If we allocate a second buffer and stuff the exclusive prefix maximum in there, our loop iterations
calculating the total surface area become entirely independent of one another. Calculating the longest
line of sight also falls out of our surface area calculation.</p><p>Here&rsquo;s the updated algorithm. I&rsquo;ve broken it out into three methods as we now calculate the line of sight in
three discrete steps:</p><ul><li>Angles</li><li>Prefix maximum</li><li>Visibility (surface area and longest line of sight)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>calculate_angles</span>(pov_height: <span style=color:#66d9ef>f32</span>, refraction: <span style=color:#66d9ef>f32</span>, angle_buf: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> [<span style=color:#66d9ef>f32</span>], elevations: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>i16</span>]) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (angle, (distance, elevation)) <span style=color:#66d9ef>in</span> zip(angle_buf.iter_mut(), elevations.enumerate()) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> curve_and_refraction <span style=color:#f92672>=</span> ((distance.ipow(<span style=color:#ae81ff>2</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>) <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> refraction)) <span style=color:#f92672>/</span> <span style=color:#66d9ef>EARTH_DIAMETER</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> elevation_prime <span style=color:#f92672>=</span> (elevation <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>) <span style=color:#f92672>+</span> curve_and_refraction
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>angle <span style=color:#f92672>=</span> (elevation_prime <span style=color:#f92672>-</span> (pov_height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>)) <span style=color:#f92672>/</span> distance
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>prefix_max</span>(prefix_max_buf: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> [<span style=color:#66d9ef>f32</span>], angle_buf: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>f32</span>]) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> highest_seen <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#66d9ef>f32</span>::<span style=color:#66d9ef>INF</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>for</span> (prefix_max, (distance, angle)) <span style=color:#66d9ef>in</span> zip(prefix_max_buf.iter_mut(), angles.enumerate()) {
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>prefix_max <span style=color:#f92672>=</span> highest_seen;
</span></span><span style=display:flex><span>        highest_seen <span style=color:#f92672>=</span> max(<span style=color:#f92672>*</span>prefix_max, highest_seen);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>visibility</span>(angles: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>f32</span>], prefix_max: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>f32</span>]) -&gt; (<span style=color:#66d9ef>f32</span>, <span style=color:#66d9ef>f32</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> ((distance, angle), prefix_max) <span style=color:#66d9ef>in</span> zip(angles.enumerate(), prefix_max) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> angle <span style=color:#f92672>&gt;</span> prefix_max {
</span></span><span style=display:flex><span>            surface_area <span style=color:#f92672>+=</span> distance <span style=color:#f92672>*</span> <span style=color:#66d9ef>TAN_ONE_RADIAN</span>
</span></span><span style=display:flex><span>            longest_distance <span style=color:#f92672>=</span> distance
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    (surface_area, longest_distance)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>line_of_sight</span>(
</span></span><span style=display:flex><span>    pov_height: <span style=color:#66d9ef>i16</span>, 
</span></span><span style=display:flex><span>    refraction: <span style=color:#66d9ef>f32</span>,
</span></span><span style=display:flex><span>    elevations: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>i16</span>], 
</span></span><span style=display:flex><span>    angle_buf: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> [<span style=color:#66d9ef>f32</span>], 
</span></span><span style=display:flex><span>    prefix_max_buf: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> [<span style=color:#66d9ef>f32</span>],
</span></span><span style=display:flex><span>) -&gt; (<span style=color:#66d9ef>f32</span>, <span style=color:#66d9ef>f32</span>) { <span style=color:#75715e>// (surface area, distance)
</span></span></span><span style=display:flex><span>    assert_eq(elevations.len(), angle_buf.len())
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    calculate_angles(pov_height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>, refraction, angle_buf, elevations);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    prefix_max(prefix_max_buf, angle_buf);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    visibility(angles, prefix_max)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=cache-pressure-ain>Cache Pressure <a href="https://www.youtube.com/watch?v=B4c_SkROzzo">Ain&rsquo;t Gonna Break My Stride</a><a hidden class=anchor aria-hidden=true href=#cache-pressure-ain>#</a></h3><p>Before parallelizing further, I noticed that our angle calculations redo the same curvature computation over and over.
When you have potentially hundreds of millions of lines of sight to process, that&rsquo;s quite a bit of extra computation. We haven&rsquo;t hit an issue
with cache pressure yet so let&rsquo;s pre-compute the curve and refraction adjustment, and also pre-compute the distances between points.
Tiles generally are of all the same <code>scale</code>, 100m, but we add it in for future use:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// generate the curvature adjustments given the scale, refraction and worst case line of sight, `max_los`.
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>generate_distances</span>(max_los: <span style=color:#66d9ef>usize</span>, refraction: <span style=color:#66d9ef>f32</span>, scale: <span style=color:#66d9ef>f32</span>) -&gt; (Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f32</span><span style=color:#f92672>&gt;</span>, Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f32</span><span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> adjusted_refraction <span style=color:#f92672>=</span> refraction <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (<span style=color:#ae81ff>1</span><span style=color:#f92672>..=</span>max_los)
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>step<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> distance <span style=color:#f92672>=</span> (step <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>) <span style=color:#f92672>*</span> scale;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> adjustment <span style=color:#f92672>=</span> (distance <span style=color:#f92672>*</span> distance <span style=color:#f92672>*</span> adjusted_refraction) <span style=color:#f92672>/</span> <span style=color:#66d9ef>EARTH_DIAMETER</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            (distance, adjustment)
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .unzip()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We now can run this once and keep it out of our angle calculation loop. Nice!</p><p>Close enough, welcome back sector distances.</p><h3 id=simd-baby>SIMD, Baby<a hidden class=anchor aria-hidden=true href=#simd-baby>#</a></h3><p>We&rsquo;ve almost squeezed every little bit of ILP out of our algorithm, so now is the time to talk about
another type of parallelism. SIMD.</p><p>SIMD stands for &ldquo;Single Instruction Multiple Data&rdquo;. SIMD widens registers by multiple times the width
of data, say 8 f32s, and allows a single instruction to be issued to do computation on all elements.</p><p>Because the parallel nature of our computation, we are a good fit for rewriting the algorithm in SIMD. Instead of calculating
a single angle at a time, we can calculate 8 at a time on my x86 machine - which has AVX2 - and as we&rsquo;ll see later, up to 16 on
AVX-512 machines.</p><p>Rust currently has an unstable feature called &ldquo;portable SIMD&rdquo; which lets us abstract over the hardware architecture,
which will work well for our most basic computations.</p><p>Trivially, we can use portable SIMD to widen both our angle and longest line of sight computations. Check it out:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// requires #![feature(portable_simd)]
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::simd::prelude::SimdFloat <span style=color:#66d9ef>as</span> _;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::simd::{LaneCount, Simd, SupportedLaneCount};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// fancy itertools macro that lets us zip multiple iterators into one big unnested tuple
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> itertools::izip;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>calculate_angles</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>VECTOR_WIDTH</span>: <span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>    pov_height: <span style=color:#66d9ef>f32</span>, 
</span></span><span style=display:flex><span>    angles_out: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> [<span style=color:#66d9ef>f32</span>], 
</span></span><span style=display:flex><span>    elevations, distances, adjustments) 
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span> 
</span></span><span style=display:flex><span>    LaneCount<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>VECTOR_WIDTH</span><span style=color:#f92672>&gt;</span> : <span style=color:#a6e22e>SupportedLaneCount</span>   
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    assert(elevations.len().is_multiple_of(<span style=color:#66d9ef>VECTOR_WIDTH</span>));
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// turn a &amp;[f32] into a &amp;[[f32; VECTOR_WIDTH]]. The r.h.s of the assignment
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// is the portion that doesn&#39;t fit into VECTOR_WIDTH, but we can ignore it since
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// the length of the slice is asserted to be a multiple of VECTOR_WIDTH
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (vector_angles, _) <span style=color:#f92672>=</span> angles_out.as_chunks_mut::<span style=color:#f92672>&lt;</span>{ <span style=color:#66d9ef>VECTOR_WIDTH</span> }<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (vector_elevations, _) <span style=color:#f92672>=</span> elevations.as_chunks::<span style=color:#f92672>&lt;</span>{ <span style=color:#66d9ef>VECTOR_WIDTH</span> }<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (vector_adjustments, _) <span style=color:#f92672>=</span> adjustments.as_chunks::<span style=color:#f92672>&lt;</span>{ <span style=color:#66d9ef>VECTOR_WIDTH</span> }<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (vector_distances, _) <span style=color:#f92672>=</span> distances.as_chunks::<span style=color:#f92672>&lt;</span>{ <span style=color:#66d9ef>VECTOR_WIDTH</span> }<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (angle_out, <span style=color:#f92672>&amp;</span>elevation, <span style=color:#f92672>&amp;</span>distance, <span style=color:#f92672>&amp;</span>adjustment) <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>izip!</span>(
</span></span><span style=display:flex><span>        vector_angles.iter_mut(),
</span></span><span style=display:flex><span>        vector_elevations.iter(),
</span></span><span style=display:flex><span>        vector_distances.iter(),
</span></span><span style=display:flex><span>        vector_adjustments.iter()
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> elevation_f32: <span style=color:#a6e22e>Simd</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f32</span>, { <span style=color:#66d9ef>VECTOR_WIDTH</span> }<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Simd::from(elevation).cast();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> elevation_prime <span style=color:#f92672>=</span> elevation_f32 <span style=color:#f92672>+</span> Simd::from_array(adjustment);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> res <span style=color:#f92672>=</span> (elevation_prime <span style=color:#f92672>-</span> Simd::splat(pov_height)) <span style=color:#f92672>/</span> Simd::from_array(distance);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        res.copy_to_slice(angle_out);
</span></span><span style=display:flex><span>    }    
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>visibility</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>VECTOR_WIDTH</span>: <span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>(angles: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>f32</span>], prefix_max: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>f32</span>], distances: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>f32</span>]) -&gt; (<span style=color:#66d9ef>f32</span>, <span style=color:#66d9ef>f32</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span> 
</span></span><span style=display:flex><span>    LaneCount<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>VECTOR_WIDTH</span><span style=color:#f92672>&gt;</span> : <span style=color:#a6e22e>SupportedLaneCount</span>   
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    assert(angles.len().is_multiple_of(<span style=color:#66d9ef>VECTOR_WIDTH</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (vector_angles, _) <span style=color:#f92672>=</span> angles.as_chunks::<span style=color:#f92672>&lt;</span>{ <span style=color:#66d9ef>VECTOR_WIDTH</span> }<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (vector_prefix, _) <span style=color:#f92672>=</span> prefix_max.as_chunks::<span style=color:#f92672>&lt;</span>{ <span style=color:#66d9ef>VECTOR_WIDTH</span> }<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (vector_distances, _) <span style=color:#f92672>=</span> distances.as_chunks::<span style=color:#f92672>&lt;</span>{ <span style=color:#66d9ef>VECTOR_WIDTH</span> }<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (simd_area, simd_longest_distance) <span style=color:#f92672>=</span> izip(angles, distances, prefix_max)
</span></span><span style=display:flex><span>        .fold((Simd::splat(<span style=color:#ae81ff>0.0</span><span style=color:#66d9ef>f32</span>), Simd::splat(<span style=color:#ae81ff>0.0</span><span style=color:#66d9ef>f32</span>)), <span style=color:#f92672>|</span>((acc_area, acc_distances), (angle, distance, prefix_max)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> mask <span style=color:#f92672>=</span> angle.simd_gt(prefix_max);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// if we don&#39;t have _any_ elements, then why carry out the rest of the computation?
</span></span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>mask.any() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> (acc_area, acc_distances);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> selected_distances <span style=color:#f92672>=</span> mask.select(distance, Simd::splat(<span style=color:#ae81ff>0.0</span><span style=color:#66d9ef>f32</span>));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> surface_area <span style=color:#f92672>=</span> selected_distances <span style=color:#f92672>*</span> Simd::splat(<span style=color:#66d9ef>TAN_ONE_RADIAN</span>);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            (acc_area <span style=color:#f92672>+</span> surface_area, acc_distances.simd_max(selected_distances))
</span></span><span style=display:flex><span>        }<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    (simd_area.reduce_sum(), simd_longest_distance.reduce_max())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>SIMD is a different way of thinking because as you may notice, there are no conditionals.
Instead, each element is compared pairwise with each other to create a &ldquo;mask&rdquo;. Then, you use
that mask to &ldquo;select&rdquo; which elements you want to use for true (the distances) and which to use
for false (zero).</p><p>Rust has some interesting codegen for the <code>!mask.any()</code> that I haven&rsquo;t fully grokked so will need to write a separate
post about, but suffice it to say that it shaved 10% off of our time. If no points are visible, there&rsquo;s
no reason to do any other calculation so this makes sense.</p><h3 id=x86-and-ieee754>x86 and IEEE754<a hidden class=anchor aria-hidden=true href=#x86-and-ieee754>#</a></h3><p>Rust strives to be a safe language, so all float computations are done <em>without</em> the fastmath flags. Enabling the fastmath
flags in Rust is annoying, and also not <a href=https://simonbyrne.github.io/notes/fastmath/>recommended for various other reasons</a>.
One reason why you might want to turn on fastmath flags is that at least on x86, some instructions such as
comparisons and floating point maximums end up generating a lot of extra instructions to comply with IEEE floating point
standards because guess what: Intel&rsquo;s instructions don&rsquo;t.</p><p>For this project, we actually don&rsquo;t care a ton about the IEEE standard for comparison or maximum as we aren&rsquo;t
generating any <code>NaN</code>s or signed zero. For x86 we implement <code>max</code> with the <code>_mm_max_ps</code> intrinsic and implement greater than with
the <code>_mm_gt_ps</code>. No extra instructions.</p><p>This gets more important in our next section because we are going to make use of the <code>max</code> instruction quite a bit,
and we need to make sure a minimal number of instructions are generated. It&rsquo;s all to help us sop avoiding the SIMD
elephant in the room: the prefix maximum calculation.</p><h3 id=parallel-scans-with-simd>Parallel Scans With SIMD<a hidden class=anchor aria-hidden=true href=#parallel-scans-with-simd>#</a></h3><p>Calculating the prefix maximum with multiple threads would induce a huge amount of overhead for a small amount
of work, so instead we want to parallelize our prefix maximum via SIMD. The level of parallelism we get out of
the algorithm will be from clearing up the instruction pipeliner and keep the carried dependencies minimal.</p><p>Because <code>max</code> is associative, we can calculate the prefix maximum for all the angles that fit within a
single SIMD register keeping all calculations independent of one another and make ILP go brrr.
Then we loop back over the data to propagate the maximum of each through the data. A common pattern you may be
picking up on.</p><p>For example, lets say we have the following angles in two 4-wide registers.</p><pre tabindex=0><code>[1, -1, 2, -2], [3, -3, 4, -4]
</code></pre><p>We can calculate the prefix max of the first register by shifting in an identity element - in our case <code>-f32::INF</code> -
and applying our binary operator <code>max</code>. Then we take result of that and shift in two identity elements
to finish calculating the prefix max in-place:</p><pre tabindex=0><code>max([   1,   -1,  2, -2],
    [-INF,    1, -1,  2])
= [1, max(-1, 1), max(2, -1), max(-2, -1)]
</code></pre><p>Then reuse that for the next in-place prefix max:</p><pre tabindex=0><code>max([   1,  max(-1, 1), max(2, -1), max(-2, -1)],
    [-INF,        -INF,          1, max(1,  -1)])
= [1, max(-1, 1), max(max(2, -1), 1), max(max(-2, -1), max(1, -1))]
= [1, 1, 2, 2]
</code></pre><p>We do the same for the second register, independently:</p><pre tabindex=0><code>max([   3,   -3,  4, -4],
    [-INF,    3, -3,  4])
= [3, max(-3, 3), max(4, -3), max(-4, 4)]
</code></pre><p>Which needs to be reused for the next in-place prefix max:</p><pre tabindex=0><code>max([   3,  max(-3, 3), max(4, -3), max(-4, 4)],
    [-INF,        -INF,          3, max(1, -1)]
= [3, 3, 4, 4]
</code></pre><p>Now, we can take the maximum of the first register, which is always the last element, and splat it across a whole SIMD
register, then call <code>max</code> to complete the process:</p><pre tabindex=0><code>max([3, 3, 4, 4],
    [2, 2, 2, 2])
= [3, 3, 4, 4]
</code></pre><p>No change here. But as you can see, associativity is what lets us do this prefix maximum calculation register
and lets us only do \(log_2(4) = 2\) calls to <code>max</code>. When we use 8 or 16 wide registers it is still \(log_2\),
so only a modest increase of one or two extra shifts. It also saves us from having to compute something
like <code>max(max(max(1, -1), 2), -2)</code>.</p><p>If you are interested in the nitty-gritty, you can take a look <a href=https://github.com/AllTheLines/CacheTVS/blob/1bcc17c68114398209f027339bd81e810e6cf8c3/crates/total-viewsheds/src/cpu/vector_intrinsics.rs#L173>at the implementation</a> or also take a look
at <a href=https://en.algorithmica.org/hpc/algorithms/prefix/>this website</a> or <a href=https://www.adms-conf.org/2020-camera-ready/ADMS20_05.pdf>this paper</a>
that were great guides and help in implementing a prefix maximum.</p><h3 id=reduction>Reduction<a hidden class=anchor aria-hidden=true href=#reduction>#</a></h3><p>Now that we are able to calculate the longest line of sight for a given point, we need to do this for every point on
the map. Since we also only go in a single direction, we need to run that for every angle.</p><p>As cores finish up doing their single angle heatmap and line of sight calculation, we simply accumulate their results
into a single &ldquo;final map&rdquo; which is the result of the accumulated data for all 360 degrees.</p><h3 id=final-results>Final Results<a hidden class=anchor aria-hidden=true href=#final-results>#</a></h3><p>After implementing all of the above optimizations and absolutely squeezing the rock as hard as I could,
water did in fact come out. We took the computation from 120 seconds an angle, down to</p><p>DRUM ROLL PLEASE</p><p><em><strong>75 seconds per angle.</strong></em></p><p>Astounding. This brought us down to 57 minutes for all of Everest on my 8 core machine.
Every little bit of optimization and tuning brought us here, and it was because of the hard work
we put in that we were getting very close to something usable for a world run. There was one last thing that was
holding me back: AVX-512.</p><p>Very, very recently, AMD released its Turin line of processor which has full AVX-512F support. Which means rather
than having AVX-512 be two AVX2 calculations in a trench-coat, it is a first-class citizen. Renting a top of the line AMD
Turin and our use of const generics and portable SIMD implementation let us seamlessly turn on support for a
16-wide angle calculation, prefix max, and longest line of sight calculation. Enabling it <em>halved</em> the time per angle,
cutting down the calculation to an average of 35 seconds per angle.</p><p>Using the Turins also unlocked a huge number of more cores. I found that 48 cores was the sweet spot for our algorithm.
Now instead of taking an hour, with 48 cores and AVX512, we were taking 4 minutes for all of Everest. <strong>ALL OF EVEREST</strong>.
This is a 160x speedup over the initial GPU algorithm.</p><p>It should be noted that there are a good number of cores that get wasted when running with a core count
that doesn&rsquo;t evenly divide 360. Cores idling waiting for the next angle which doesn&rsquo;t come but we leave this as future work.</p><h2 id=a-full-world-run>A Full World Run<a hidden class=anchor aria-hidden=true href=#a-full-world-run>#</a></h2><p>Now that we were confident that we had the quickest algorithm we could think up, it was time to run the longest line
of sight algorithm for every tile in the whole world. Tom <a href=%5Bhere%5D(https://tombh.co.uk/packing-world-lines-of-sight)>calculated</a>
the worst case line of sight that covered the globe. Chunking the world up as such ended with roughly 2500 tiles ranging
from 50 kilometers across to a whopping 800km across.</p><p>Since our algorithm is \(O(n^3)\) where \(n\) is the worst case line of sight, small tiles will run in much quicker than
4 minutes, while larger tiles will take <em>much</em> longer than 4 minutes. About 50% of the tiles are under 450km, whereas
50% of the total area of all tiles comes in at 1900 tiles and under 650km. We still had a tall task.</p><p>To process all the tiles, we took a stab at a Tom-and-Ryan version of <a href=https://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf>MapReduce</a>
cluster of 5 AMD Turin machines which we called Atlas, which you can read about <a href=https://tombh.co.uk/longest-line-of-sight#atlas-the-automater>here</a>.</p><p>All in all, the full world run took 18 hours and cost us a few hundred dollars which is much less than the
few hundred thousand that Tom initially estimated.</p><h2 id=the-final-product>The Final Product<a hidden class=anchor aria-hidden=true href=#the-final-product>#</a></h2><p>Looking for the longest line of sight? Go check it out at <a href=https://alltheviews.world>https://alltheviews.world</a> and see
our curated list of the top ten longest lines of sight. You won&rsquo;t believe number 3!</p><p>Don&rsquo;t forget to go play with the interactive map at<a href=https://mapalltheviews.world>https://map.alltheviews.world</a> to
find the longest line of sight for any location on earth, or even the longest line of sight for your country or state!</p><p>If you want to take a look at Atlas, you can so <a href=https://github.com/AllTheViews/viewview>here</a>. If you would like
to take a look at all the code this blog post is about, here is the
link for the repo of our total viewshed algorithm, <a href=https://github.com/AllTheViews/CacheTVS>CacheTVS</a>.</p><h2 id=acknowledgements>Acknowledgements<a hidden class=anchor aria-hidden=true href=#acknowledgements>#</a></h2><p>I&rsquo;d like to acknowledge Tom for being the rock for which all this research was able to take place.
My family and friends for listening to my insane ramblings. They really didn&rsquo;t know much that was going on
until it became visual.</p><p>A big thanks Matt Flatt for teaching my CS4400 class in college that gave me the language and tools to approach
these performance issues.</p><p>I&rsquo;d also like to thank my dog for spending many of my late nights curled up on the couch with me.</p><p>So long, and thanks for all the fish!</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ryan.berge.rs/>Ryan Berger's Page</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>